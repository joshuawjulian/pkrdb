{"version":3,"sources":["../../src/holdem/state.ts","../../src/holdem/action.ts","../../src/holdem/card.ts","../../src/holdem/engineUtils.ts"],"sourcesContent":["import { z } from 'zod';\nimport {\n\tActionSchema,\n\tPlayerBetType,\n\tPlayerBlindType,\n\tPlayerStraddleType,\n\tPokerRoundType,\n\tPokerRounds,\n\tisDealerAction,\n} from './action.js';\nimport { CardSchema } from './card.js';\nimport { getWagers } from './engineUtils.js';\n\nexport const OptionsSchema = z.object({\n\treopenPercent: z.number().default(1.0),\n});\n\nexport type OptionsType = z.infer<typeof OptionsSchema>;\n\nexport const StackSchema = z.union([\n\tz.number().positive(),\n\tz.literal('unknown'),\n]);\nexport type StackType = z.infer<typeof StackSchema>;\n\nexport const GameStateSchema = z.object({\n\toptions: OptionsSchema.default({}),\n\tactionList: ActionSchema.array(),\n\tplayers: z\n\t\t.object({\n\t\t\tstartingStack: StackSchema,\n\t\t\tcards: CardSchema.array().length(2),\n\t\t})\n\t\t.array()\n\t\t.min(2),\n});\n\nexport type GameStateType = z.infer<typeof GameStateSchema>;\n\nexport const stateAtIndex = (\n\tstate: GameStateType,\n\tindex: number,\n): GameStateType => {\n\tif (index < 0 || index > state.actionList.length) throw 'Invalid index';\n\tlet newState: GameStateType = { ...state };\n\tnewState.actionList = state.actionList.slice(0, index);\n\treturn newState;\n};\n\n// export type ActionByRoundSeatType = Record<\n// \t(typeof PokerRounds)[number],\n// \tRecord<number, PlayerActionType[]>\n// >;\n// export const getActionByRoundSeat = (\n// \tstate: GameStateType,\n// ): ActionByRoundSeatType => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst actionBySeatByRound: ActionByRoundSeatType =\n// \t\t{} as ActionByRoundSeatType;\n// \tfor (let round of PokerRounds) {\n// \t\tactionBySeatByRound[round] = {} as Record<number, PlayerActionType[]>;\n// \t\tfor (let seat = 0; seat < state.players.length; seat++) {\n// \t\t\tactionBySeatByRound[round][seat] = actionByRound[round].filter(\n// \t\t\t\t(action) => action.seat === seat,\n// \t\t\t);\n// \t\t}\n// \t}\n// \treturn actionBySeatByRound;\n// };\n\n// export type ActionBySeatRoundType = Record<\n// \tnumber,\n// \tRecord<(typeof PokerRounds)[number], PlayerActionType[]>\n// >;\n// export const getActionBySeatRound = (\n// \tstate: GameStateType,\n// ): ActionBySeatRoundType => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst actionBySeatByRound: ActionBySeatRoundType =\n// \t\t{} as ActionBySeatRoundType;\n// \tfor (let seat = 0; seat < state.players.length; seat++) {\n// \t\tactionBySeatByRound[seat] = {} as Record<\n// \t\t\t(typeof PokerRounds)[number],\n// \t\t\tPlayerActionType[]\n// \t\t>;\n// \t\tfor (let round of PokerRounds) {\n// \t\t\tactionBySeatByRound[seat][round] = actionByRound[round].filter(\n// \t\t\t\t(action) => action.seat === seat,\n// \t\t\t);\n// \t\t}\n// \t}\n// \treturn actionBySeatByRound;\n// };\n\n// export const getNextDealerOption = (state: GameStateType): DealerOptionType => {\n// \tconst roundIndexes = getRoundIndexes(state);\n// \tconst nextRound = PokerRounds.find((round) => roundIndexes[round] === -1);\n// \tif (nextRound === undefined) return { action: 'showdown' };\n// \tif (nextRound === 'flop') return { action: 'flop', cards: 3 };\n// \tif (nextRound === 'turn') return { action: 'turn', cards: 1 };\n// \tif (nextRound === 'river') return { action: 'river', cards: 1 };\n// \treturn { action: 'preflop' };\n// };\n\n// export const getCurrentRound = (state: GameStateType): PokerRoundType => {\n// \tconst roundIndexes = getRoundIndicies(state);\n// \tlet currentRound: PokerRoundType | undefined;\n// \tPokerRounds.forEach((round) => {\n// \t\tif (roundIndexes[round] !== -1) {\n// \t\t\tcurrentRound = round;\n// \t\t}\n// \t});\n// \tif (currentRound === undefined) return 'preflop';\n// \treturn currentRound;\n// };\n\n// export const largestWagerByRound = (\n// \tstate: GameStateType,\n// ): Record<PokerRoundType, number> => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst largestWagerByRound: Record<PokerRoundType, number> = {} as Record<\n// \t\tPokerRoundType,\n// \t\tnumber\n// \t>;\n// \tfor (let round of PokerRounds) {\n// \t\tconst wagers = actionByRound[round]\n// \t\t\t.filter(increaseWagerAction)\n// \t\t\t.map((action) => action.amount);\n\n// \t\tlargestWagerByRound[round] = Math.max(...wagers, 0);\n// \t}\n// \treturn largestWagerByRound;\n// };\n\nexport type WageredEachRoundType = Record<\n\tnumber,\n\tRecord<PokerRoundType, number>\n>;\n\nexport const wageredEachRound = (\n\tstate: GameStateType,\n): WageredEachRoundType => {\n\tlet wagered = {} as WageredEachRoundType;\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\twagered[seat] = {} as Record<PokerRoundType, number>;\n\t\tfor (let round of PokerRounds) {\n\t\t\twagered[seat][round] = 0;\n\t\t}\n\t}\n\n\tlet currRound: PokerRoundType = 'preflop';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst currAction = state.actionList[i];\n\t\tif (currAction.action === 'showdown') break;\n\t\tif (isDealerAction(currAction)) {\n\t\t\tcurrRound = currAction.action;\n\t\t\tcontinue;\n\t\t}\n\t\tif (currAction.action === 'fold' || currAction.action === 'check') continue;\n\t\twagered[currAction.seat][currRound] = currAction.amount;\n\t}\n\n\treturn wagered;\n};\n\nexport const remainingStackSize = (\n\tstate: GameStateType,\n): Record<number, number | 'unknown'> => {\n\tlet remainingStack = {} as Record<number, number | 'unknown'>;\n\tstate.players.forEach((player, index) => {\n\t\tremainingStack[index] = player.startingStack;\n\t});\n\n\tlet wagered = wageredEachRound(state);\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\tlet stack = remainingStack[seat];\n\t\tif (stack === 'unknown') continue;\n\t\tlet totalForSeat = 0;\n\t\tfor (let round of PokerRounds) {\n\t\t\ttotalForSeat += wagered[seat][round];\n\t\t}\n\t\tremainingStack[seat] = stack - totalForSeat;\n\t}\n\n\treturn remainingStack;\n};\n\nexport const rotateArray = <T>(arr: T[], count: number): T[] => {\n\treturn [...arr.slice(count), ...arr.slice(0, count)];\n};\n\nexport const nextSeat = (seats: number[]): number[] => {\n\tlet updatedSeats = rotateArray(seats, 1);\n\tconsole.log('nextSeat() | ' + seats + ' -> ' + updatedSeats);\n\treturn updatedSeats;\n};\n\nexport type RoundIndiciesType = {\n\t[round in PokerRoundType]: number;\n};\n\nexport let getRoundIndicies = (state: GameStateType): RoundIndiciesType => {\n\tlet roundIndicies: RoundIndiciesType = {\n\t\tpreflop: -1,\n\t\tflop: -1,\n\t\tturn: -1,\n\t\triver: -1,\n\t};\n\n\tfor (let i = state.actionList.length - 1; i >= 0; i--) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction)) {\n\t\t\troundIndicies[currAction.action as PokerRoundType] = i;\n\t\t}\n\t}\n\n\treturn roundIndicies;\n};\n\nexport const toString = (state: GameStateType): string => {\n\tlet str = '';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst action = state.actionList[i];\n\t\tif (isDealerAction(action)) {\n\t\t\tstr += action.action + '\\n';\n\t\t} else {\n\t\t\tstr += action.seat + ' ' + action.action + ' ';\n\t\t\tif ('amount' in action) str = str + action.amount;\n\t\t\tstr = str + '\\n';\n\t\t}\n\t}\n\treturn str;\n};\n\nexport let actionListToString = (state: GameStateType): string => {\n\tlet str = '';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst action = state.actionList[i];\n\t\tif (isDealerAction(action)) {\n\t\t\tstr += `${action.action} `;\n\t\t} else {\n\t\t\tstr += `[${action.seat}]${action.action} `;\n\t\t\tif ('amount' in action) str = str + action.amount;\n\t\t}\n\t\tstr += ` | `;\n\t}\n\treturn str;\n};\n\nexport let getBets = (state: GameStateType): PlayerBetType[] => {\n\tlet wagers = getWagers(state);\n\tlet bets: PlayerBetType[] = [];\n\twagers.forEach((action) => {\n\t\tif (action.action === 'bet') {\n\t\t\tbets.push(action);\n\t\t}\n\t});\n\treturn bets;\n};\n\nexport let getBlindsStraddles = (\n\tstate: GameStateType,\n): (PlayerStraddleType | PlayerBlindType)[] => {\n\tlet wagers = getWagers(state);\n\tlet blindsStraddles: (PlayerStraddleType | PlayerBlindType)[] = [];\n\twagers.forEach((action) => {\n\t\tif (action.action === 'blind' || action.action === 'straddle') {\n\t\t\tblindsStraddles.push(action);\n\t\t}\n\t});\n\treturn blindsStraddles;\n};\n","import { z } from 'zod';\nimport { CardSchema } from './card.js';\n\nexport const PlayerFoldSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('fold'),\n});\nexport type PlayerFoldType = z.infer<typeof PlayerFoldSchema>;\nexport const PlayerCallSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('call'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerCallType = z.infer<typeof PlayerCallSchema>;\nexport const PlayerBetSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('bet'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerBetType = z.infer<typeof PlayerBetSchema>;\nexport const PlayerCheckSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('check'),\n});\nexport type PlayerCheckType = z.infer<typeof PlayerCheckSchema>;\nexport const PlayerBlindSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('blind'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerBlindType = z.infer<typeof PlayerBlindSchema>;\nexport const PlayerStraddleSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('straddle'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerStraddleType = z.infer<typeof PlayerStraddleSchema>;\n\nexport type PlayerIncreaseWagerType =\n\t| PlayerBetType\n\t| PlayerBlindType\n\t| PlayerStraddleType;\n\nexport const increaseWagerAction = (\n\taction: ActionType,\n): action is PlayerIncreaseWagerType => {\n\treturn (\n\t\taction.action === 'bet' ||\n\t\taction.action === 'blind' ||\n\t\taction.action === 'straddle'\n\t);\n};\n\n// player actions first\nexport const PlayerActionsSchema = z.discriminatedUnion('action', [\n\tPlayerBetSchema,\n\tPlayerBlindSchema,\n\tPlayerCallSchema,\n\tPlayerCheckSchema,\n\tPlayerFoldSchema,\n\tPlayerStraddleSchema,\n]);\n\n// These increase the bet size AND give action after being called\nexport const PlayerBlindActions = ['blind', 'straddle'] as const;\n\n// These attempt to close the action\nexport const PlayerCloseActions = ['check', 'call', 'fold'] as const;\n\nexport const DealerActionSchema = z.discriminatedUnion('action', [\n\tz.object({\n\t\taction: z.literal('preflop'),\n\t}),\n\tz.object({\n\t\taction: z.literal('flop'),\n\t\tflop: z.array(CardSchema).length(3),\n\t}),\n\tz.object({\n\t\taction: z.literal('turn'),\n\t\tturn: CardSchema,\n\t}),\n\tz.object({\n\t\taction: z.literal('river'),\n\t\triver: CardSchema,\n\t}),\n\tz.object({\n\t\taction: z.literal('showdown'),\n\t}),\n]);\n\nexport type PlayerActionType = z.infer<typeof PlayerActionsSchema>;\nexport type DealerActionType = z.infer<typeof DealerActionSchema>;\n\nexport const ActionSchema = z.discriminatedUnion('action', [\n\t...PlayerActionsSchema.options,\n\t...DealerActionSchema.options,\n]);\n\nexport type ActionType = z.infer<typeof ActionSchema>;\n\nexport const PlayerOptionFoldSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('fold'),\n});\nexport type PlayerOptionFoldType = z.infer<typeof PlayerOptionFoldSchema>;\n\nexport let PlayerOptionBlindSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('blind'),\n});\nexport type PlayerOptionBlindType = z.infer<typeof PlayerOptionBlindSchema>;\n\nexport let PlayerOptionStraddleSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('straddle'),\n});\nexport type PlayerOptionStraddleType = z.infer<\n\ttypeof PlayerOptionStraddleSchema\n>;\n\nexport const PlayerOptionCallSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('call'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerOptionCallType = z.infer<typeof PlayerOptionCallSchema>;\nexport const PlayerOptionBetSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('bet'),\n\tmin: z.union([z.number().min(0), z.literal('unknown')]),\n\tmax: z.union([z.number().min(0), z.literal('unknown')]),\n});\nexport type PlayerOptionBetType = z.infer<typeof PlayerOptionBetSchema>;\nexport const PlayerOptionCheckSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('check'),\n});\nexport type PlayerOptionCheckType = z.infer<typeof PlayerOptionCheckSchema>;\n\nexport const PlayerOptionSchema = z.discriminatedUnion('action', [\n\tPlayerOptionFoldSchema,\n\tPlayerOptionCallSchema,\n\tPlayerOptionBetSchema,\n\tPlayerOptionCheckSchema,\n\tPlayerOptionBlindSchema,\n\tPlayerOptionStraddleSchema,\n]);\n\nexport type PlayerOptionType = z.infer<typeof PlayerOptionSchema>;\n\nexport const DealerOptionSchema = z.discriminatedUnion('action', [\n\tz.object({\n\t\taction: z.literal('preflop'),\n\t}),\n\tz.object({\n\t\taction: z.literal('flop'),\n\t\tcards: z.literal(3),\n\t}),\n\tz.object({\n\t\taction: z.literal('turn'),\n\t\tcards: z.literal(1),\n\t}),\n\tz.object({\n\t\taction: z.literal('river'),\n\t\tcards: z.literal(1),\n\t}),\n\tz.object({\n\t\taction: z.literal('showdown'),\n\t}),\n]);\n\nexport const PokerRounds = ['preflop', 'flop', 'turn', 'river'] as const;\n\nexport type PokerRoundType = (typeof PokerRounds)[number];\n\nexport type DealerOptionType = z.infer<typeof DealerOptionSchema>;\n\nexport const NextOptionSchema = z.discriminatedUnion('action', [\n\t...PlayerOptionSchema.options,\n\t...DealerOptionSchema.options,\n]);\n\nexport type NextOptionType = z.infer<typeof NextOptionSchema>;\n\nexport const isPlayerAction = (\n\taction: ActionType,\n): action is PlayerActionType => {\n\treturn PlayerActionsSchema.safeParse(action).success;\n};\n\nexport const isDealerAction = (\n\taction: ActionType,\n): action is DealerActionType => {\n\treturn DealerActionSchema.safeParse(action).success;\n};\n\nexport let isPlayerOption = (\n\toption: NextOptionType,\n): option is PlayerOptionType => {\n\treturn PlayerOptionSchema.safeParse(option).success;\n};\n\nexport let isPlayerOptions = (\n\toptions: NextOptionType[],\n): options is PlayerOptionType[] => {\n\treturn z.array(PlayerOptionSchema).safeParse(options).success;\n};\n\nexport let isDealerOption = (\n\toption: NextOptionType,\n): option is DealerOptionType => {\n\treturn DealerOptionSchema.safeParse(option).success;\n};\n\nexport let isDealerOptions = (\n\toptions: NextOptionType[],\n): options is DealerOptionType[] => {\n\treturn z.array(DealerOptionSchema).safeParse(options).success;\n};\n\nexport let getNextRoundOption = (round: PokerRoundType): DealerOptionType => {\n\tif (round === 'preflop') {\n\t\treturn { action: 'flop', cards: 3 };\n\t} else if (round === 'flop') {\n\t\treturn { action: 'turn', cards: 1 };\n\t} else if (round === 'turn') {\n\t\treturn { action: 'river', cards: 1 };\n\t} else {\n\t\treturn { action: 'showdown' };\n\t}\n};\n\nexport let optionArrayToString = (options: NextOptionType[]): string[] => {\n\treturn options.reduce<string[]>(\n\t\t(acc, option) => [...acc, option.action],\n\t\tnew Array<string>(),\n\t);\n};\n","import { z } from 'zod';\n\nexport const CardRankSchema = z.union([\n\tz.literal('2'),\n\tz.literal('3'),\n\tz.literal('4'),\n\tz.literal('5'),\n\tz.literal('6'),\n\tz.literal('7'),\n\tz.literal('8'),\n\tz.literal('9'),\n\tz.literal('T'),\n\tz.literal('J'),\n\tz.literal('Q'),\n\tz.literal('K'),\n\tz.literal('A'),\n\tz.literal('X'),\n]);\n\nexport const CardSuitSchema = z.union([\n\tz.literal('s'),\n\tz.literal('h'),\n\tz.literal('d'),\n\tz.literal('c'),\n\tz.literal('x'),\n]);\n\nexport type CardSuitType = z.infer<typeof CardSuitSchema>;\n\nexport const CardSchema = z.object({\n\trank: CardRankSchema,\n\tsuit: CardSuitSchema,\n});\n\nexport type CardType = z.infer<typeof CardSchema>;\n\nexport let suitToCharacter = (suit: CardSuitType) => {\n\tswitch (suit) {\n\t\tcase 's':\n\t\t\treturn '♠';\n\t\tcase 'h':\n\t\t\treturn '♥';\n\t\tcase 'd':\n\t\t\treturn '♦';\n\t\tcase 'c':\n\t\t\treturn '♣';\n\t}\n\treturn 'x';\n};\n\nexport let cardToString = (card: CardType) => {\n\treturn card.rank + suitToCharacter(card.suit);\n};\n","import {\n\ttype ActionType,\n\ttype DealerActionType,\n\ttype PlayerActionType,\n\ttype PlayerBetType,\n\ttype PlayerIncreaseWagerType,\n\ttype PokerRoundType,\n\tPokerRounds,\n\tincreaseWagerAction,\n\tisDealerAction,\n\tisDealerOptions,\n\tisPlayerAction,\n\tisPlayerOptions,\n\toptionArrayToString,\n} from './action.js';\nimport { next } from './engine.js';\nimport {\n\ttype GameStateType,\n\ttype StackType,\n\tgetBets,\n\tgetBlindsStraddles,\n} from './state.js';\n\nexport let playerActionsCurrentRound = (\n\tstate: GameStateType,\n): PlayerActionType[] => {\n\tlet currentRound = getCurrentRound(state);\n\tlet idxStart = getIndexOfRoundStart(state, currentRound);\n\n\tlet playerActions: PlayerActionType[] = [];\n\tfor (let i = idxStart; i < state.actionList.length; i++) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (!isDealerAction(currAction)) {\n\t\t\tplayerActions.push(currAction);\n\t\t}\n\t}\n\n\treturn playerActions;\n};\n\nexport let getCurrentRound = (state: GameStateType): PokerRoundType => {\n\tlet dealerActions = getAllDealerActions(state);\n\tif (dealerActions.length === 0) throw 'No dealer actions found';\n\tif (dealerActions[dealerActions.length - 1].action === 'showdown')\n\t\tthrow 'Game is over';\n\treturn dealerActions[dealerActions.length - 1].action as PokerRoundType;\n};\n\nexport let getAllDealerActions = (state: GameStateType): DealerActionType[] => {\n\tlet dealerActions: DealerActionType[] = [];\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction)) {\n\t\t\tdealerActions.push(currAction);\n\t\t}\n\t}\n\tif (dealerActions.length === 0) throw 'No dealer actions found';\n\treturn dealerActions;\n};\n\nexport let getIndexOfRoundStart = (\n\tstate: GameStateType,\n\tround: PokerRoundType,\n): number => {\n\tfor (let i = state.actionList.length - 1; i >= 0; i--) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction) && currAction.action === round) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nexport let getSeatsAtThisRoundStart = (state: GameStateType): number[] => {\n\tlet currentRound = getCurrentRound(state);\n\treturn getSeatsAtRoundStart(state, currentRound);\n};\n\nexport let getSeatsAtRoundStart = (\n\tstate: GameStateType,\n\tround: PokerRoundType,\n): number[] => {\n\tlet seats: number[] = [...Array(state.players.length).keys()];\n\tlet idxRoundStart = getIndexOfRoundStart(state, round);\n\n\tfor (let i = 0; i < idxRoundStart; i++) {\n\t\tlet action = state.actionList[i];\n\t\tif (\n\t\t\tisPlayerAction(action) &&\n\t\t\t(action.action === 'fold' || ('isAllIn' in action && action.isAllIn))\n\t\t) {\n\t\t\tseats = seats.filter((seat) => seat !== action.seat);\n\t\t}\n\t}\n\treturn seats;\n};\n\nexport let cycleSeats = (seats: number[]): number[] => {\n\tif (seats.length > 1) return [...seats.slice(1), seats[0]];\n\treturn seats;\n};\n\nexport let findLargestBlind = (state: GameStateType): number => {\n\treturn state.actionList.reduce((acc, curr) => {\n\t\tif (curr.action === 'blind' && curr.amount > acc) return curr.amount;\n\t\treturn acc;\n\t}, 0);\n};\n\n// { PokerRound : [largest wager by seat index]}\nexport type LargestWagersType = Record<PokerRoundType, number[]>;\n\n// This can be calls or allins just largest by seat per round\nexport let largestWagersByRound = (\n\tstate: GameStateType,\n): Record<PokerRoundType, number[]> => {\n\tlet emptyWager = [...Array(state.players.length).keys()].map(() => 0);\n\tlet wagers = {\n\t\tpreflop: [...emptyWager],\n\t\tflop: [...emptyWager],\n\t\tturn: [...emptyWager],\n\t\triver: [...emptyWager],\n\t} as Record<PokerRoundType, number[]>;\n\n\tlet currRound: PokerRoundType;\n\tstate.actionList.forEach((action, idx) => {\n\t\tif (isDealerAction(action)) {\n\t\t\tcurrRound = action.action as PokerRoundType;\n\t\t\treturn;\n\t\t}\n\t\tif (isPlayerAction(action)) {\n\t\t\tif (\n\t\t\t\t'amount' in action &&\n\t\t\t\twagers[currRound][action.seat] < action.amount\n\t\t\t) {\n\t\t\t\twagers[currRound][action.seat] = action.amount;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn wagers;\n};\n\n// { PokerRound : [remaining stack at start of round by type]}\nexport type StacksAtRoundType = Record<PokerRoundType, StackType[]>;\n\nexport let getStacksAtStartOfRound = (\n\tstate: GameStateType,\n): StacksAtRoundType => {\n\tlet startingStacks: StackType[] = [];\n\tstate.players.forEach((player) => {\n\t\tstartingStacks.push(player.startingStack);\n\t});\n\n\tlet stacks = {\n\t\tpreflop: structuredClone(startingStacks),\n\t\tflop: structuredClone(startingStacks),\n\t\tturn: structuredClone(startingStacks),\n\t\triver: structuredClone(startingStacks),\n\t} as StacksAtRoundType;\n\n\tlet largestWagers = largestWagersByRound(state);\n\n\t// go through each seat and by round get the largest wager additing it\n\t// to the seatTotal then subtracting it from the starting stack\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\tlet seatTotal = 0;\n\t\tPokerRounds.forEach((round: PokerRoundType) => {\n\t\t\tlet startingStack = stacks['preflop'][seat];\n\t\t\tif (startingStack === 'unknown') return;\n\t\t\tif (round === 'preflop') {\n\t\t\t\tseatTotal = largestWagers[round][seat];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstacks[round][seat] = startingStack - seatTotal;\n\t\t\tseatTotal += largestWagers[round][seat];\n\t\t});\n\t}\n\treturn stacks;\n};\n\nexport let getStacksAtStartOfCurrentRound = (\n\tstate: GameStateType,\n): StackType[] => {\n\treturn getStacksAtStartOfRound(state)[getCurrentRound(state)];\n};\n\nexport let getStacks = (state: GameStateType): StackType[] => {\n\tlet largestWagers = largestWagersByRound(state);\n\tlet stacks: StackType[] = [];\n\tstate.players.forEach((player) => {\n\t\tstacks.push(player.startingStack);\n\t});\n\n\tPokerRounds.forEach((round: PokerRoundType) => {\n\t\tlet numPlayers = state.players.length;\n\t\tfor (let seat = 0; seat < numPlayers; seat++) {\n\t\t\tlet currStack = stacks[seat];\n\t\t\tif (currStack !== 'unknown')\n\t\t\t\tstacks[seat] = currStack - largestWagers[round][seat];\n\t\t}\n\t});\n\treturn stacks;\n};\n\n// Returns seat order after last action\n// only seats with action behind will be in the order\nexport let getSeatOrder = (state: GameStateType): number[] => {\n\tlet playerActions: PlayerActionType[] = playerActionsCurrentRound(state);\n\tlet seatsOrder = getSeatsAtThisRoundStart(state);\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet action = playerActions[i];\n\t\tif (action.action === 'fold') {\n\t\t\tseatsOrder = seatsOrder.filter((seat) => seat !== action.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tif ('isAllIn' in action && action.isAllIn) {\n\t\t\tseatsOrder = seatsOrder.filter((seat) => seat !== action.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tseatsOrder = cycleSeats(seatsOrder);\n\t}\n\treturn seatsOrder;\n};\n\n// get all wagers for the current round (blinds/straddle/bets)\nexport let getWagers = (state: GameStateType): PlayerIncreaseWagerType[] => {\n\tlet playerActions: PlayerActionType[] = playerActionsCurrentRound(state);\n\tlet wagers: PlayerIncreaseWagerType[] = [];\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet action = playerActions[i];\n\t\tif (increaseWagerAction(action)) wagers.push(action);\n\t}\n\treturn wagers;\n};\n\n// returns an array where each seat index is the largest wager for this round\nexport let getLargestWagers = (state: GameStateType): number[] => {\n\tlet largestWagers = [...Array(state.players.length).keys()].map(() => 0);\n\tlet wagers: PlayerIncreaseWagerType[] = getWagers(state);\n\twagers.forEach((wager) => {\n\t\tif (wager.amount > largestWagers[wager.seat]) {\n\t\t\tlargestWagers[wager.seat] = wager.amount;\n\t\t}\n\t});\n\treturn largestWagers;\n};\n\nexport let getLargestWager = (\n\tstate: GameStateType,\n): PlayerIncreaseWagerType | null => {\n\tlet wagers = getWagers(state);\n\tif (wagers.length === 0) return null;\n\treturn wagers.reduce((acc, curr) => {\n\t\tif (curr.amount > acc.amount) return curr;\n\t\treturn acc;\n\t});\n};\n\nexport let getLargestWagerAmount = (state: GameStateType): number => {\n\treturn getLargestWager(state)?.amount ?? 0;\n};\n\nexport let getRemainingStacks = (state: GameStateType): StackType[] => {\n\tlet currRound = getCurrentRound(state);\n\tlet stacksAtStart = getStacksAtStartOfRound(state)[currRound];\n\tlet largestWager = getLargestWagers(state);\n\n\tlet numPlayers = state.players.length;\n\tlet remainingStacks = [...stacksAtStart];\n\tfor (let seat = 0; seat < numPlayers; seat++) {\n\t\tlet currStartStack = stacksAtStart[seat];\n\t\tif (currStartStack !== 'unknown')\n\t\t\tremainingStacks[seat] = currStartStack - largestWager[seat];\n\t}\n\treturn remainingStacks;\n};\n\n// Get the min viable bet for the current seat\n// disregarding if they actually have the stack to do it\nexport let getMinBet = (state: GameStateType): number => {\n\tlet minBet = 0;\n\tlet wagers = getWagers(state);\n\tlet currSeat = getSeatOrder(state).at(0);\n\tif (currSeat === undefined) throw 'No seats found';\n\tlet largestBlind = findLargestBlind(state);\n\tminBet = largestBlind;\n\tlet reopenWagers: PlayerIncreaseWagerType[] = [];\n\tif (wagers.length > 1) {\n\t\t// figure which wagers reopened betting\n\t\tfor (let i = 0; i < wagers.length; i++) {\n\t\t\tif (wagers[i].isAllIn) {\n\t\t\t\t// 2 or more previous reopen wagers this round\n\t\t\t\tif (reopenWagers.length > 1) {\n\t\t\t\t\tlet largeBet = reopenWagers[reopenWagers.length - 1].amount;\n\t\t\t\t\tlet smallBet = reopenWagers[reopenWagers.length - 2].amount;\n\t\t\t\t\tlet wagerStep = largeBet - smallBet;\n\t\t\t\t\tif (wagers[i].amount >= largeBet + wagerStep) {\n\t\t\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 1 open wagers this round\n\t\t\t\tif (reopenWagers.length === 1) {\n\t\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (wagers.length === 1) {\n\t\treopenWagers.push(wagers[0]);\n\t}\n\n\tif (reopenWagers.length === 0) {\n\t\tminBet = largestBlind;\n\t}\n\tif (reopenWagers.length === 1) {\n\t\tminBet = reopenWagers[0].amount * 2;\n\t}\n\tif (reopenWagers.length > 1) {\n\t\tlet largeBet = reopenWagers[reopenWagers.length - 1].amount;\n\t\tlet smallBet = reopenWagers[reopenWagers.length - 2].amount;\n\t\tlet wagerStep = largeBet - smallBet;\n\t\tminBet = largeBet + wagerStep;\n\t}\n\treturn minBet;\n};\n\nexport let getLargestStack = (state: GameStateType): number => {\n\tlet stacks = getStacksAtStartOfCurrentRound(state);\n\tlet largestStack = 0;\n\tfor (let i = 0; i < stacks.length; i++) {\n\t\tlet currStack = stacks[i];\n\t\tif (currStack !== 'unknown' && currStack > largestStack) {\n\t\t\tlargestStack = currStack;\n\t\t}\n\t}\n\treturn largestStack;\n};\n\nexport let getMaxBet = (state: GameStateType): number => {\n\tlet currSeat = getSeatOrder(state).at(0);\n\tif (currSeat === undefined) throw 'No seats found';\n\n\tlet maxBet = getRemainingStacks(state).at(currSeat);\n\tif (maxBet === undefined) throw 'No stack found';\n\n\tif (maxBet === 'unknown') return getLargestStack(state);\n\n\treturn maxBet;\n};\n\n/*\n\tGet the min and max bet for the player with the current action\n*/\nexport let getMinMaxBet = (state: GameStateType): [number, number] => {\n\tlet minBet = getMinBet(state);\n\tlet maxBet = getMaxBet(state);\n\t// not able to make a full open\n\tif (minBet > maxBet) return [maxBet, maxBet];\n\treturn [minBet, maxBet];\n};\n\nexport let hasNonBlindAction = (state: GameStateType): boolean => {\n\treturn (\n\t\tstate.actionList.filter(\n\t\t\t(a) => a.action !== 'blind' && a.action !== 'preflop',\n\t\t).length > 0\n\t);\n};\n\nexport let hasNonBlindStraddleAction = (state: GameStateType): boolean => {\n\treturn (\n\t\tstate.actionList.filter(\n\t\t\t(a) =>\n\t\t\t\ta.action !== 'blind' &&\n\t\t\t\ta.action !== 'straddle' &&\n\t\t\t\ta.action !== 'preflop',\n\t\t).length > 0\n\t);\n};\n\n// Returns true if the current round is complete\n// IE: The bets are not matched by all players/all checked\nexport let actionComplete = (state: GameStateType): boolean => {\n\tif (state.actionList.length <= 1) return false;\n\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seats = getSeatsAtThisRoundStart(state);\n\tlet largestWager = getLargestWagerAmount(state);\n\n\t// check if we need to even play this round\n\t// all players are all in or have folded\n\tif (playerActions.length === 0 && seats.length <= 1) {\n\t\treturn true;\n\t}\n\n\t// no bets, ensure everyone has acted (checked or folded)\n\t// and it isnt preflop\n\tif (\n\t\tplayerActions.length === seats.length &&\n\t\tlargestWager === 0 &&\n\t\tgetCurrentRound(state) !== 'preflop'\n\t) {\n\t\treturn true;\n\t}\n\n\t//preflop blind/straddle edge case\n\tif (getCurrentRound(state) === 'preflop' && getBets(state).length === 0) {\n\t\treturn (\n\t\t\tplayerActions.length === seats.length + getBlindsStraddles(state).length\n\t\t);\n\t}\n\n\t// Here we know someone has bet\n\t// Now we need to check that everyone else has matched the bet with a call or folded\n\tlet seatsToAct = structuredClone(seats);\n\tlet largestBetAction: null | PlayerBetType = null;\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet currAction = playerActions[i];\n\t\tif (currAction.action === 'fold') {\n\t\t\tseatsToAct = seatsToAct.filter((seat) => seat !== currAction.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tif (currAction.action === 'bet') {\n\t\t\tif (\n\t\t\t\tlargestBetAction === null ||\n\t\t\t\tcurrAction.amount > largestBetAction.amount\n\t\t\t) {\n\t\t\t\tlargestBetAction = currAction;\n\t\t\t}\n\t\t}\n\t\tseatsToAct = cycleSeats(seatsToAct);\n\t}\n\n\treturn seatsToAct[0] === largestBetAction?.seat;\n};\n\nexport let numPlayersNotFolded = (state: GameStateType): number => {\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seats = getSeatsAtThisRoundStart(state);\n\tplayerActions.forEach((action) => {\n\t\tif (action.action === 'fold') {\n\t\t\tseats = seats.filter((seat) => seat !== action.seat);\n\t\t}\n\t});\n\treturn seats.length;\n};\n\nexport let getSeatActions = (\n\tstate: GameStateType,\n): Record<number, PlayerActionType[]> => {\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seatActions: Record<number, PlayerActionType[]> = {};\n\tfor (let i = 0; i < state.players.length; i++) seatActions[i] = [];\n\tplayerActions.forEach((action) => {\n\t\tseatActions[action.seat].push(action);\n\t});\n\treturn seatActions;\n};\n\nexport let validateAction = (\n\tstate: GameStateType,\n\tnextAction: ActionType,\n): boolean | string => {\n\tlet options = next(state);\n\tif (options.length < 1)\n\t\treturn `There are less than one options (${options.length})`;\n\tif (isDealerAction(nextAction) && isDealerOptions(options)) {\n\t\tif (options.length > 1) return 'Dealer Options must only be length 1';\n\t\tif (options[0].action !== nextAction.action) {\n\t\t\treturn `Dealer action '${nextAction.action}' does not match option '${options[0].action}'`;\n\t\t}\n\t\treturn true;\n\t}\n\tif (isPlayerAction(nextAction) && isPlayerOptions(options)) {\n\t\tlet option = options.find((o) => o.action === nextAction.action);\n\t\tif (option === undefined)\n\t\t\treturn `nextAction ${\n\t\t\t\tnextAction.action\n\t\t\t} not in options ${optionArrayToString(options)}`;\n\n\t\tif (option.seat !== nextAction.seat)\n\t\t\treturn `Seat ${nextAction.seat} does not match option seat ${option.seat}`;\n\n\t\t// fold, check, blind, straddle are valid on their own\n\t\tif (\n\t\t\tnextAction.action === 'fold' ||\n\t\t\tnextAction.action === 'check' ||\n\t\t\tnextAction.action === 'straddle' ||\n\t\t\tnextAction.action === 'blind'\n\t\t)\n\t\t\treturn true;\n\n\t\t// call\n\t\tif (nextAction.action === 'call' && option.action === 'call') {\n\t\t\tif (nextAction.amount === option.amount) return true;\n\t\t\treturn `Call amount ${nextAction.amount} does not match option amount ${option.amount}`;\n\t\t}\n\n\t\t// bet\n\t\tif (nextAction.action === 'bet' && option.action === 'bet') {\n\t\t\tif (option.min === 'unknown' || option.max === 'unknown') return true;\n\t\t\tif (nextAction.amount >= option.min && nextAction.amount <= option.max)\n\t\t\t\treturn true;\n\t\t\treturn `Bet amount ${nextAction.amount} not in range ${option.min} - ${option.max}`;\n\t\t}\n\t}\n\n\treturn `Something went wrong => received action: ${\n\t\tnextAction.action\n\t} | options: ${optionArrayToString(options)}`;\n};\n\nexport let validateState = (state: GameStateType): boolean | string => {\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tlet prevState = structuredClone(state);\n\t\tprevState.actionList = state.actionList.slice(0, i);\n\t\tlet nextAction = state.actionList[i];\n\t\tlet valid = validateAction(prevState, nextAction);\n\t\tif (valid !== true) return `Invalid action at index ${i}: ${valid}`;\n\t}\n\treturn true;\n};\n"],"mappings":"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","names":["z","z","z","z","z"]}