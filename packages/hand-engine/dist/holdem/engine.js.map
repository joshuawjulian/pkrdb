{"version":3,"sources":["../../src/holdem/action.ts","../../src/holdem/card.ts","../../src/holdem/state.ts","../../src/holdem/engineUtils.ts","../../src/holdem/engine.ts"],"sourcesContent":["import { z } from 'zod';\nimport { CardSchema } from './card.js';\n\nexport const PlayerFoldSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('fold'),\n});\nexport type PlayerFoldType = z.infer<typeof PlayerFoldSchema>;\nexport const PlayerCallSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('call'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerCallType = z.infer<typeof PlayerCallSchema>;\nexport const PlayerBetSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('bet'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerBetType = z.infer<typeof PlayerBetSchema>;\nexport const PlayerCheckSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('check'),\n});\nexport type PlayerCheckType = z.infer<typeof PlayerCheckSchema>;\nexport const PlayerBlindSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('blind'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerBlindType = z.infer<typeof PlayerBlindSchema>;\nexport const PlayerStraddleSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('straddle'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerStraddleType = z.infer<typeof PlayerStraddleSchema>;\n\nexport type PlayerIncreaseWagerType =\n\t| PlayerBetType\n\t| PlayerBlindType\n\t| PlayerStraddleType;\n\nexport const increaseWagerAction = (\n\taction: ActionType,\n): action is PlayerIncreaseWagerType => {\n\treturn (\n\t\taction.action === 'bet' ||\n\t\taction.action === 'blind' ||\n\t\taction.action === 'straddle'\n\t);\n};\n\n// player actions first\nexport const PlayerActionsSchema = z.discriminatedUnion('action', [\n\tPlayerBetSchema,\n\tPlayerBlindSchema,\n\tPlayerCallSchema,\n\tPlayerCheckSchema,\n\tPlayerFoldSchema,\n\tPlayerStraddleSchema,\n]);\n\n// These increase the bet size AND give action after being called\nexport const PlayerBlindActions = ['blind', 'straddle'] as const;\n\n// These attempt to close the action\nexport const PlayerCloseActions = ['check', 'call', 'fold'] as const;\n\nexport const DealerActionSchema = z.discriminatedUnion('action', [\n\tz.object({\n\t\taction: z.literal('preflop'),\n\t}),\n\tz.object({\n\t\taction: z.literal('flop'),\n\t\tflop: z.array(CardSchema).length(3),\n\t}),\n\tz.object({\n\t\taction: z.literal('turn'),\n\t\tturn: CardSchema,\n\t}),\n\tz.object({\n\t\taction: z.literal('river'),\n\t\triver: CardSchema,\n\t}),\n\tz.object({\n\t\taction: z.literal('showdown'),\n\t}),\n]);\n\nexport type PlayerActionType = z.infer<typeof PlayerActionsSchema>;\nexport type DealerActionType = z.infer<typeof DealerActionSchema>;\n\nexport const ActionSchema = z.discriminatedUnion('action', [\n\t...PlayerActionsSchema.options,\n\t...DealerActionSchema.options,\n]);\n\nexport type ActionType = z.infer<typeof ActionSchema>;\n\nexport const PlayerOptionFoldSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('fold'),\n});\nexport type PlayerOptionFoldType = z.infer<typeof PlayerOptionFoldSchema>;\n\nexport let PlayerOptionBlindSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('blind'),\n});\nexport type PlayerOptionBlindType = z.infer<typeof PlayerOptionBlindSchema>;\n\nexport let PlayerOptionStraddleSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('straddle'),\n});\nexport type PlayerOptionStraddleType = z.infer<\n\ttypeof PlayerOptionStraddleSchema\n>;\n\nexport const PlayerOptionCallSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('call'),\n\tamount: z.number(),\n\tisAllIn: z.boolean(),\n});\nexport type PlayerOptionCallType = z.infer<typeof PlayerOptionCallSchema>;\nexport const PlayerOptionBetSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('bet'),\n\tmin: z.union([z.number().min(0), z.literal('unknown')]),\n\tmax: z.union([z.number().min(0), z.literal('unknown')]),\n});\nexport type PlayerOptionBetType = z.infer<typeof PlayerOptionBetSchema>;\nexport const PlayerOptionCheckSchema = z.object({\n\tseat: z.number(),\n\taction: z.literal('check'),\n});\nexport type PlayerOptionCheckType = z.infer<typeof PlayerOptionCheckSchema>;\n\nexport const PlayerOptionSchema = z.discriminatedUnion('action', [\n\tPlayerOptionFoldSchema,\n\tPlayerOptionCallSchema,\n\tPlayerOptionBetSchema,\n\tPlayerOptionCheckSchema,\n\tPlayerOptionBlindSchema,\n\tPlayerOptionStraddleSchema,\n]);\n\nexport type PlayerOptionType = z.infer<typeof PlayerOptionSchema>;\n\nexport const DealerOptionSchema = z.discriminatedUnion('action', [\n\tz.object({\n\t\taction: z.literal('preflop'),\n\t}),\n\tz.object({\n\t\taction: z.literal('flop'),\n\t\tcards: z.literal(3),\n\t}),\n\tz.object({\n\t\taction: z.literal('turn'),\n\t\tcards: z.literal(1),\n\t}),\n\tz.object({\n\t\taction: z.literal('river'),\n\t\tcards: z.literal(1),\n\t}),\n\tz.object({\n\t\taction: z.literal('showdown'),\n\t}),\n]);\n\nexport const PokerRounds = ['preflop', 'flop', 'turn', 'river'] as const;\n\nexport type PokerRoundType = (typeof PokerRounds)[number];\n\nexport type DealerOptionType = z.infer<typeof DealerOptionSchema>;\n\nexport const NextOptionSchema = z.discriminatedUnion('action', [\n\t...PlayerOptionSchema.options,\n\t...DealerOptionSchema.options,\n]);\n\nexport type NextOptionType = z.infer<typeof NextOptionSchema>;\n\nexport const isPlayerAction = (\n\taction: ActionType,\n): action is PlayerActionType => {\n\treturn PlayerActionsSchema.safeParse(action).success;\n};\n\nexport const isDealerAction = (\n\taction: ActionType,\n): action is DealerActionType => {\n\treturn DealerActionSchema.safeParse(action).success;\n};\n\nexport let isPlayerOption = (\n\toption: NextOptionType,\n): option is PlayerOptionType => {\n\treturn PlayerOptionSchema.safeParse(option).success;\n};\n\nexport let isPlayerOptions = (\n\toptions: NextOptionType[],\n): options is PlayerOptionType[] => {\n\treturn z.array(PlayerOptionSchema).safeParse(options).success;\n};\n\nexport let isDealerOption = (\n\toption: NextOptionType,\n): option is DealerOptionType => {\n\treturn DealerOptionSchema.safeParse(option).success;\n};\n\nexport let isDealerOptions = (\n\toptions: NextOptionType[],\n): options is DealerOptionType[] => {\n\treturn z.array(DealerOptionSchema).safeParse(options).success;\n};\n\nexport let getNextRoundOption = (round: PokerRoundType): DealerOptionType => {\n\tif (round === 'preflop') {\n\t\treturn { action: 'flop', cards: 3 };\n\t} else if (round === 'flop') {\n\t\treturn { action: 'turn', cards: 1 };\n\t} else if (round === 'turn') {\n\t\treturn { action: 'river', cards: 1 };\n\t} else {\n\t\treturn { action: 'showdown' };\n\t}\n};\n\nexport let optionArrayToString = (options: NextOptionType[]): string[] => {\n\treturn options.reduce<string[]>(\n\t\t(acc, option) => [...acc, option.action],\n\t\tnew Array<string>(),\n\t);\n};\n","import { z } from 'zod';\n\nexport const CardRankSchema = z.union([\n\tz.literal('2'),\n\tz.literal('3'),\n\tz.literal('4'),\n\tz.literal('5'),\n\tz.literal('6'),\n\tz.literal('7'),\n\tz.literal('8'),\n\tz.literal('9'),\n\tz.literal('T'),\n\tz.literal('J'),\n\tz.literal('Q'),\n\tz.literal('K'),\n\tz.literal('A'),\n\tz.literal('X'),\n]);\n\nexport const CardSuitSchema = z.union([\n\tz.literal('s'),\n\tz.literal('h'),\n\tz.literal('d'),\n\tz.literal('c'),\n\tz.literal('x'),\n]);\n\nexport type CardSuitType = z.infer<typeof CardSuitSchema>;\n\nexport const CardSchema = z.object({\n\trank: CardRankSchema,\n\tsuit: CardSuitSchema,\n});\n\nexport type CardType = z.infer<typeof CardSchema>;\n\nexport let suitToCharacter = (suit: CardSuitType) => {\n\tswitch (suit) {\n\t\tcase 's':\n\t\t\treturn '♠';\n\t\tcase 'h':\n\t\t\treturn '♥';\n\t\tcase 'd':\n\t\t\treturn '♦';\n\t\tcase 'c':\n\t\t\treturn '♣';\n\t}\n\treturn 'x';\n};\n\nexport let cardToString = (card: CardType) => {\n\treturn card.rank + suitToCharacter(card.suit);\n};\n","import { z } from 'zod';\nimport {\n\tActionSchema,\n\tPlayerBetType,\n\tPlayerBlindType,\n\tPlayerStraddleType,\n\tPokerRoundType,\n\tPokerRounds,\n\tisDealerAction,\n} from './action.js';\nimport { CardSchema } from './card.js';\nimport { getWagers } from './engineUtils.js';\n\nexport const OptionsSchema = z.object({\n\treopenPercent: z.number().default(1.0),\n});\n\nexport type OptionsType = z.infer<typeof OptionsSchema>;\n\nexport const StackSchema = z.union([\n\tz.number().positive(),\n\tz.literal('unknown'),\n]);\nexport type StackType = z.infer<typeof StackSchema>;\n\nexport const GameStateSchema = z.object({\n\toptions: OptionsSchema.default({}),\n\tactionList: ActionSchema.array(),\n\tplayers: z\n\t\t.object({\n\t\t\tstartingStack: StackSchema,\n\t\t\tcards: CardSchema.array().length(2),\n\t\t})\n\t\t.array()\n\t\t.min(2),\n});\n\nexport type GameStateType = z.infer<typeof GameStateSchema>;\n\nexport const stateAtIndex = (\n\tstate: GameStateType,\n\tindex: number,\n): GameStateType => {\n\tif (index < 0 || index > state.actionList.length) throw 'Invalid index';\n\tlet newState: GameStateType = { ...state };\n\tnewState.actionList = state.actionList.slice(0, index);\n\treturn newState;\n};\n\n// export type ActionByRoundSeatType = Record<\n// \t(typeof PokerRounds)[number],\n// \tRecord<number, PlayerActionType[]>\n// >;\n// export const getActionByRoundSeat = (\n// \tstate: GameStateType,\n// ): ActionByRoundSeatType => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst actionBySeatByRound: ActionByRoundSeatType =\n// \t\t{} as ActionByRoundSeatType;\n// \tfor (let round of PokerRounds) {\n// \t\tactionBySeatByRound[round] = {} as Record<number, PlayerActionType[]>;\n// \t\tfor (let seat = 0; seat < state.players.length; seat++) {\n// \t\t\tactionBySeatByRound[round][seat] = actionByRound[round].filter(\n// \t\t\t\t(action) => action.seat === seat,\n// \t\t\t);\n// \t\t}\n// \t}\n// \treturn actionBySeatByRound;\n// };\n\n// export type ActionBySeatRoundType = Record<\n// \tnumber,\n// \tRecord<(typeof PokerRounds)[number], PlayerActionType[]>\n// >;\n// export const getActionBySeatRound = (\n// \tstate: GameStateType,\n// ): ActionBySeatRoundType => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst actionBySeatByRound: ActionBySeatRoundType =\n// \t\t{} as ActionBySeatRoundType;\n// \tfor (let seat = 0; seat < state.players.length; seat++) {\n// \t\tactionBySeatByRound[seat] = {} as Record<\n// \t\t\t(typeof PokerRounds)[number],\n// \t\t\tPlayerActionType[]\n// \t\t>;\n// \t\tfor (let round of PokerRounds) {\n// \t\t\tactionBySeatByRound[seat][round] = actionByRound[round].filter(\n// \t\t\t\t(action) => action.seat === seat,\n// \t\t\t);\n// \t\t}\n// \t}\n// \treturn actionBySeatByRound;\n// };\n\n// export const getNextDealerOption = (state: GameStateType): DealerOptionType => {\n// \tconst roundIndexes = getRoundIndexes(state);\n// \tconst nextRound = PokerRounds.find((round) => roundIndexes[round] === -1);\n// \tif (nextRound === undefined) return { action: 'showdown' };\n// \tif (nextRound === 'flop') return { action: 'flop', cards: 3 };\n// \tif (nextRound === 'turn') return { action: 'turn', cards: 1 };\n// \tif (nextRound === 'river') return { action: 'river', cards: 1 };\n// \treturn { action: 'preflop' };\n// };\n\n// export const getCurrentRound = (state: GameStateType): PokerRoundType => {\n// \tconst roundIndexes = getRoundIndicies(state);\n// \tlet currentRound: PokerRoundType | undefined;\n// \tPokerRounds.forEach((round) => {\n// \t\tif (roundIndexes[round] !== -1) {\n// \t\t\tcurrentRound = round;\n// \t\t}\n// \t});\n// \tif (currentRound === undefined) return 'preflop';\n// \treturn currentRound;\n// };\n\n// export const largestWagerByRound = (\n// \tstate: GameStateType,\n// ): Record<PokerRoundType, number> => {\n// \tconst actionByRound = getActionByRound(state);\n// \tconst largestWagerByRound: Record<PokerRoundType, number> = {} as Record<\n// \t\tPokerRoundType,\n// \t\tnumber\n// \t>;\n// \tfor (let round of PokerRounds) {\n// \t\tconst wagers = actionByRound[round]\n// \t\t\t.filter(increaseWagerAction)\n// \t\t\t.map((action) => action.amount);\n\n// \t\tlargestWagerByRound[round] = Math.max(...wagers, 0);\n// \t}\n// \treturn largestWagerByRound;\n// };\n\nexport type WageredEachRoundType = Record<\n\tnumber,\n\tRecord<PokerRoundType, number>\n>;\n\nexport const wageredEachRound = (\n\tstate: GameStateType,\n): WageredEachRoundType => {\n\tlet wagered = {} as WageredEachRoundType;\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\twagered[seat] = {} as Record<PokerRoundType, number>;\n\t\tfor (let round of PokerRounds) {\n\t\t\twagered[seat][round] = 0;\n\t\t}\n\t}\n\n\tlet currRound: PokerRoundType = 'preflop';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst currAction = state.actionList[i];\n\t\tif (currAction.action === 'showdown') break;\n\t\tif (isDealerAction(currAction)) {\n\t\t\tcurrRound = currAction.action;\n\t\t\tcontinue;\n\t\t}\n\t\tif (currAction.action === 'fold' || currAction.action === 'check') continue;\n\t\twagered[currAction.seat][currRound] = currAction.amount;\n\t}\n\n\treturn wagered;\n};\n\nexport const remainingStackSize = (\n\tstate: GameStateType,\n): Record<number, number | 'unknown'> => {\n\tlet remainingStack = {} as Record<number, number | 'unknown'>;\n\tstate.players.forEach((player, index) => {\n\t\tremainingStack[index] = player.startingStack;\n\t});\n\n\tlet wagered = wageredEachRound(state);\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\tlet stack = remainingStack[seat];\n\t\tif (stack === 'unknown') continue;\n\t\tlet totalForSeat = 0;\n\t\tfor (let round of PokerRounds) {\n\t\t\ttotalForSeat += wagered[seat][round];\n\t\t}\n\t\tremainingStack[seat] = stack - totalForSeat;\n\t}\n\n\treturn remainingStack;\n};\n\nexport const rotateArray = <T>(arr: T[], count: number): T[] => {\n\treturn [...arr.slice(count), ...arr.slice(0, count)];\n};\n\nexport const nextSeat = (seats: number[]): number[] => {\n\tlet updatedSeats = rotateArray(seats, 1);\n\tconsole.log('nextSeat() | ' + seats + ' -> ' + updatedSeats);\n\treturn updatedSeats;\n};\n\nexport type RoundIndiciesType = {\n\t[round in PokerRoundType]: number;\n};\n\nexport let getRoundIndicies = (state: GameStateType): RoundIndiciesType => {\n\tlet roundIndicies: RoundIndiciesType = {\n\t\tpreflop: -1,\n\t\tflop: -1,\n\t\tturn: -1,\n\t\triver: -1,\n\t};\n\n\tfor (let i = state.actionList.length - 1; i >= 0; i--) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction)) {\n\t\t\troundIndicies[currAction.action as PokerRoundType] = i;\n\t\t}\n\t}\n\n\treturn roundIndicies;\n};\n\nexport const toString = (state: GameStateType): string => {\n\tlet str = '';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst action = state.actionList[i];\n\t\tif (isDealerAction(action)) {\n\t\t\tstr += action.action + '\\n';\n\t\t} else {\n\t\t\tstr += action.seat + ' ' + action.action + ' ';\n\t\t\tif ('amount' in action) str = str + action.amount;\n\t\t\tstr = str + '\\n';\n\t\t}\n\t}\n\treturn str;\n};\n\nexport let actionListToString = (state: GameStateType): string => {\n\tlet str = '';\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tconst action = state.actionList[i];\n\t\tif (isDealerAction(action)) {\n\t\t\tstr += `${action.action} `;\n\t\t} else {\n\t\t\tstr += `[${action.seat}]${action.action} `;\n\t\t\tif ('amount' in action) str = str + action.amount;\n\t\t}\n\t\tstr += ` | `;\n\t}\n\treturn str;\n};\n\nexport let getBets = (state: GameStateType): PlayerBetType[] => {\n\tlet wagers = getWagers(state);\n\tlet bets: PlayerBetType[] = [];\n\twagers.forEach((action) => {\n\t\tif (action.action === 'bet') {\n\t\t\tbets.push(action);\n\t\t}\n\t});\n\treturn bets;\n};\n\nexport let getBlindsStraddles = (\n\tstate: GameStateType,\n): (PlayerStraddleType | PlayerBlindType)[] => {\n\tlet wagers = getWagers(state);\n\tlet blindsStraddles: (PlayerStraddleType | PlayerBlindType)[] = [];\n\twagers.forEach((action) => {\n\t\tif (action.action === 'blind' || action.action === 'straddle') {\n\t\t\tblindsStraddles.push(action);\n\t\t}\n\t});\n\treturn blindsStraddles;\n};\n","import {\n\ttype ActionType,\n\ttype DealerActionType,\n\ttype PlayerActionType,\n\ttype PlayerBetType,\n\ttype PlayerIncreaseWagerType,\n\ttype PokerRoundType,\n\tPokerRounds,\n\tincreaseWagerAction,\n\tisDealerAction,\n\tisDealerOptions,\n\tisPlayerAction,\n\tisPlayerOptions,\n\toptionArrayToString,\n} from './action.js';\nimport { next } from './engine.js';\nimport {\n\ttype GameStateType,\n\ttype StackType,\n\tgetBets,\n\tgetBlindsStraddles,\n} from './state.js';\n\nexport let playerActionsCurrentRound = (\n\tstate: GameStateType,\n): PlayerActionType[] => {\n\tlet currentRound = getCurrentRound(state);\n\tlet idxStart = getIndexOfRoundStart(state, currentRound);\n\n\tlet playerActions: PlayerActionType[] = [];\n\tfor (let i = idxStart; i < state.actionList.length; i++) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (!isDealerAction(currAction)) {\n\t\t\tplayerActions.push(currAction);\n\t\t}\n\t}\n\n\treturn playerActions;\n};\n\nexport let getCurrentRound = (state: GameStateType): PokerRoundType => {\n\tlet dealerActions = getAllDealerActions(state);\n\tif (dealerActions.length === 0) throw 'No dealer actions found';\n\tif (dealerActions[dealerActions.length - 1].action === 'showdown')\n\t\tthrow 'Game is over';\n\treturn dealerActions[dealerActions.length - 1].action as PokerRoundType;\n};\n\nexport let getAllDealerActions = (state: GameStateType): DealerActionType[] => {\n\tlet dealerActions: DealerActionType[] = [];\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction)) {\n\t\t\tdealerActions.push(currAction);\n\t\t}\n\t}\n\tif (dealerActions.length === 0) throw 'No dealer actions found';\n\treturn dealerActions;\n};\n\nexport let getIndexOfRoundStart = (\n\tstate: GameStateType,\n\tround: PokerRoundType,\n): number => {\n\tfor (let i = state.actionList.length - 1; i >= 0; i--) {\n\t\tlet currAction = state.actionList[i];\n\t\tif (isDealerAction(currAction) && currAction.action === round) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\n\nexport let getSeatsAtThisRoundStart = (state: GameStateType): number[] => {\n\tlet currentRound = getCurrentRound(state);\n\treturn getSeatsAtRoundStart(state, currentRound);\n};\n\nexport let getSeatsAtRoundStart = (\n\tstate: GameStateType,\n\tround: PokerRoundType,\n): number[] => {\n\tlet seats: number[] = [...Array(state.players.length).keys()];\n\tlet idxRoundStart = getIndexOfRoundStart(state, round);\n\n\tfor (let i = 0; i < idxRoundStart; i++) {\n\t\tlet action = state.actionList[i];\n\t\tif (\n\t\t\tisPlayerAction(action) &&\n\t\t\t(action.action === 'fold' || ('isAllIn' in action && action.isAllIn))\n\t\t) {\n\t\t\tseats = seats.filter((seat) => seat !== action.seat);\n\t\t}\n\t}\n\treturn seats;\n};\n\nexport let cycleSeats = (seats: number[]): number[] => {\n\tif (seats.length > 1) return [...seats.slice(1), seats[0]];\n\treturn seats;\n};\n\nexport let findLargestBlind = (state: GameStateType): number => {\n\treturn state.actionList.reduce((acc, curr) => {\n\t\tif (curr.action === 'blind' && curr.amount > acc) return curr.amount;\n\t\treturn acc;\n\t}, 0);\n};\n\n// { PokerRound : [largest wager by seat index]}\nexport type LargestWagersType = Record<PokerRoundType, number[]>;\n\n// This can be calls or allins just largest by seat per round\nexport let largestWagersByRound = (\n\tstate: GameStateType,\n): Record<PokerRoundType, number[]> => {\n\tlet emptyWager = [...Array(state.players.length).keys()].map(() => 0);\n\tlet wagers = {\n\t\tpreflop: [...emptyWager],\n\t\tflop: [...emptyWager],\n\t\tturn: [...emptyWager],\n\t\triver: [...emptyWager],\n\t} as Record<PokerRoundType, number[]>;\n\n\tlet currRound: PokerRoundType;\n\tstate.actionList.forEach((action, idx) => {\n\t\tif (isDealerAction(action)) {\n\t\t\tcurrRound = action.action as PokerRoundType;\n\t\t\treturn;\n\t\t}\n\t\tif (isPlayerAction(action)) {\n\t\t\tif (\n\t\t\t\t'amount' in action &&\n\t\t\t\twagers[currRound][action.seat] < action.amount\n\t\t\t) {\n\t\t\t\twagers[currRound][action.seat] = action.amount;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn wagers;\n};\n\n// { PokerRound : [remaining stack at start of round by type]}\nexport type StacksAtRoundType = Record<PokerRoundType, StackType[]>;\n\nexport let getStacksAtStartOfRound = (\n\tstate: GameStateType,\n): StacksAtRoundType => {\n\tlet startingStacks: StackType[] = [];\n\tstate.players.forEach((player) => {\n\t\tstartingStacks.push(player.startingStack);\n\t});\n\n\tlet stacks = {\n\t\tpreflop: structuredClone(startingStacks),\n\t\tflop: structuredClone(startingStacks),\n\t\tturn: structuredClone(startingStacks),\n\t\triver: structuredClone(startingStacks),\n\t} as StacksAtRoundType;\n\n\tlet largestWagers = largestWagersByRound(state);\n\n\t// go through each seat and by round get the largest wager additing it\n\t// to the seatTotal then subtracting it from the starting stack\n\tfor (let seat = 0; seat < state.players.length; seat++) {\n\t\tlet seatTotal = 0;\n\t\tPokerRounds.forEach((round: PokerRoundType) => {\n\t\t\tlet startingStack = stacks['preflop'][seat];\n\t\t\tif (startingStack === 'unknown') return;\n\t\t\tif (round === 'preflop') {\n\t\t\t\tseatTotal = largestWagers[round][seat];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstacks[round][seat] = startingStack - seatTotal;\n\t\t\tseatTotal += largestWagers[round][seat];\n\t\t});\n\t}\n\treturn stacks;\n};\n\nexport let getStacksAtStartOfCurrentRound = (\n\tstate: GameStateType,\n): StackType[] => {\n\treturn getStacksAtStartOfRound(state)[getCurrentRound(state)];\n};\n\nexport let getStacks = (state: GameStateType): StackType[] => {\n\tlet largestWagers = largestWagersByRound(state);\n\tlet stacks: StackType[] = [];\n\tstate.players.forEach((player) => {\n\t\tstacks.push(player.startingStack);\n\t});\n\n\tPokerRounds.forEach((round: PokerRoundType) => {\n\t\tlet numPlayers = state.players.length;\n\t\tfor (let seat = 0; seat < numPlayers; seat++) {\n\t\t\tlet currStack = stacks[seat];\n\t\t\tif (currStack !== 'unknown')\n\t\t\t\tstacks[seat] = currStack - largestWagers[round][seat];\n\t\t}\n\t});\n\treturn stacks;\n};\n\n// Returns seat order after last action\n// only seats with action behind will be in the order\nexport let getSeatOrder = (state: GameStateType): number[] => {\n\tlet playerActions: PlayerActionType[] = playerActionsCurrentRound(state);\n\tlet seatsOrder = getSeatsAtThisRoundStart(state);\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet action = playerActions[i];\n\t\tif (action.action === 'fold') {\n\t\t\tseatsOrder = seatsOrder.filter((seat) => seat !== action.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tif ('isAllIn' in action && action.isAllIn) {\n\t\t\tseatsOrder = seatsOrder.filter((seat) => seat !== action.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tseatsOrder = cycleSeats(seatsOrder);\n\t}\n\treturn seatsOrder;\n};\n\n// get all wagers for the current round (blinds/straddle/bets)\nexport let getWagers = (state: GameStateType): PlayerIncreaseWagerType[] => {\n\tlet playerActions: PlayerActionType[] = playerActionsCurrentRound(state);\n\tlet wagers: PlayerIncreaseWagerType[] = [];\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet action = playerActions[i];\n\t\tif (increaseWagerAction(action)) wagers.push(action);\n\t}\n\treturn wagers;\n};\n\n// returns an array where each seat index is the largest wager for this round\nexport let getLargestWagers = (state: GameStateType): number[] => {\n\tlet largestWagers = [...Array(state.players.length).keys()].map(() => 0);\n\tlet wagers: PlayerIncreaseWagerType[] = getWagers(state);\n\twagers.forEach((wager) => {\n\t\tif (wager.amount > largestWagers[wager.seat]) {\n\t\t\tlargestWagers[wager.seat] = wager.amount;\n\t\t}\n\t});\n\treturn largestWagers;\n};\n\nexport let getLargestWager = (\n\tstate: GameStateType,\n): PlayerIncreaseWagerType | null => {\n\tlet wagers = getWagers(state);\n\tif (wagers.length === 0) return null;\n\treturn wagers.reduce((acc, curr) => {\n\t\tif (curr.amount > acc.amount) return curr;\n\t\treturn acc;\n\t});\n};\n\nexport let getLargestWagerAmount = (state: GameStateType): number => {\n\treturn getLargestWager(state)?.amount ?? 0;\n};\n\nexport let getRemainingStacks = (state: GameStateType): StackType[] => {\n\tlet currRound = getCurrentRound(state);\n\tlet stacksAtStart = getStacksAtStartOfRound(state)[currRound];\n\tlet largestWager = getLargestWagers(state);\n\n\tlet numPlayers = state.players.length;\n\tlet remainingStacks = [...stacksAtStart];\n\tfor (let seat = 0; seat < numPlayers; seat++) {\n\t\tlet currStartStack = stacksAtStart[seat];\n\t\tif (currStartStack !== 'unknown')\n\t\t\tremainingStacks[seat] = currStartStack - largestWager[seat];\n\t}\n\treturn remainingStacks;\n};\n\n// Get the min viable bet for the current seat\n// disregarding if they actually have the stack to do it\nexport let getMinBet = (state: GameStateType): number => {\n\tlet minBet = 0;\n\tlet wagers = getWagers(state);\n\tlet currSeat = getSeatOrder(state).at(0);\n\tif (currSeat === undefined) throw 'No seats found';\n\tlet largestBlind = findLargestBlind(state);\n\tminBet = largestBlind;\n\tlet reopenWagers: PlayerIncreaseWagerType[] = [];\n\tif (wagers.length > 1) {\n\t\t// figure which wagers reopened betting\n\t\tfor (let i = 0; i < wagers.length; i++) {\n\t\t\tif (wagers[i].isAllIn) {\n\t\t\t\t// 2 or more previous reopen wagers this round\n\t\t\t\tif (reopenWagers.length > 1) {\n\t\t\t\t\tlet largeBet = reopenWagers[reopenWagers.length - 1].amount;\n\t\t\t\t\tlet smallBet = reopenWagers[reopenWagers.length - 2].amount;\n\t\t\t\t\tlet wagerStep = largeBet - smallBet;\n\t\t\t\t\tif (wagers[i].amount >= largeBet + wagerStep) {\n\t\t\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// 1 open wagers this round\n\t\t\t\tif (reopenWagers.length === 1) {\n\t\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treopenWagers.push(wagers[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif (wagers.length === 1) {\n\t\treopenWagers.push(wagers[0]);\n\t}\n\n\tif (reopenWagers.length === 0) {\n\t\tminBet = largestBlind;\n\t}\n\tif (reopenWagers.length === 1) {\n\t\tminBet = reopenWagers[0].amount * 2;\n\t}\n\tif (reopenWagers.length > 1) {\n\t\tlet largeBet = reopenWagers[reopenWagers.length - 1].amount;\n\t\tlet smallBet = reopenWagers[reopenWagers.length - 2].amount;\n\t\tlet wagerStep = largeBet - smallBet;\n\t\tminBet = largeBet + wagerStep;\n\t}\n\treturn minBet;\n};\n\nexport let getLargestStack = (state: GameStateType): number => {\n\tlet stacks = getStacksAtStartOfCurrentRound(state);\n\tlet largestStack = 0;\n\tfor (let i = 0; i < stacks.length; i++) {\n\t\tlet currStack = stacks[i];\n\t\tif (currStack !== 'unknown' && currStack > largestStack) {\n\t\t\tlargestStack = currStack;\n\t\t}\n\t}\n\treturn largestStack;\n};\n\nexport let getMaxBet = (state: GameStateType): number => {\n\tlet currSeat = getSeatOrder(state).at(0);\n\tif (currSeat === undefined) throw 'No seats found';\n\n\tlet maxBet = getRemainingStacks(state).at(currSeat);\n\tif (maxBet === undefined) throw 'No stack found';\n\n\tif (maxBet === 'unknown') return getLargestStack(state);\n\n\treturn maxBet;\n};\n\n/*\n\tGet the min and max bet for the player with the current action\n*/\nexport let getMinMaxBet = (state: GameStateType): [number, number] => {\n\tlet minBet = getMinBet(state);\n\tlet maxBet = getMaxBet(state);\n\t// not able to make a full open\n\tif (minBet > maxBet) return [maxBet, maxBet];\n\treturn [minBet, maxBet];\n};\n\nexport let hasNonBlindAction = (state: GameStateType): boolean => {\n\treturn (\n\t\tstate.actionList.filter(\n\t\t\t(a) => a.action !== 'blind' && a.action !== 'preflop',\n\t\t).length > 0\n\t);\n};\n\nexport let hasNonBlindStraddleAction = (state: GameStateType): boolean => {\n\treturn (\n\t\tstate.actionList.filter(\n\t\t\t(a) =>\n\t\t\t\ta.action !== 'blind' &&\n\t\t\t\ta.action !== 'straddle' &&\n\t\t\t\ta.action !== 'preflop',\n\t\t).length > 0\n\t);\n};\n\n// Returns true if the current round is complete\n// IE: The bets are not matched by all players/all checked\nexport let actionComplete = (state: GameStateType): boolean => {\n\tif (state.actionList.length <= 1) return false;\n\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seats = getSeatsAtThisRoundStart(state);\n\tlet largestWager = getLargestWagerAmount(state);\n\n\t// check if we need to even play this round\n\t// all players are all in or have folded\n\tif (playerActions.length === 0 && seats.length <= 1) {\n\t\treturn true;\n\t}\n\n\t// no bets, ensure everyone has acted (checked or folded)\n\t// and it isnt preflop\n\tif (\n\t\tplayerActions.length === seats.length &&\n\t\tlargestWager === 0 &&\n\t\tgetCurrentRound(state) !== 'preflop'\n\t) {\n\t\treturn true;\n\t}\n\n\t//preflop blind/straddle edge case\n\tif (getCurrentRound(state) === 'preflop' && getBets(state).length === 0) {\n\t\treturn (\n\t\t\tplayerActions.length === seats.length + getBlindsStraddles(state).length\n\t\t);\n\t}\n\n\t// Here we know someone has bet\n\t// Now we need to check that everyone else has matched the bet with a call or folded\n\tlet seatsToAct = structuredClone(seats);\n\tlet largestBetAction: null | PlayerBetType = null;\n\tfor (let i = 0; i < playerActions.length; i++) {\n\t\tlet currAction = playerActions[i];\n\t\tif (currAction.action === 'fold') {\n\t\t\tseatsToAct = seatsToAct.filter((seat) => seat !== currAction.seat);\n\t\t\tcontinue;\n\t\t}\n\t\tif (currAction.action === 'bet') {\n\t\t\tif (\n\t\t\t\tlargestBetAction === null ||\n\t\t\t\tcurrAction.amount > largestBetAction.amount\n\t\t\t) {\n\t\t\t\tlargestBetAction = currAction;\n\t\t\t}\n\t\t}\n\t\tseatsToAct = cycleSeats(seatsToAct);\n\t}\n\n\treturn seatsToAct[0] === largestBetAction?.seat;\n};\n\nexport let numPlayersNotFolded = (state: GameStateType): number => {\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seats = getSeatsAtThisRoundStart(state);\n\tplayerActions.forEach((action) => {\n\t\tif (action.action === 'fold') {\n\t\t\tseats = seats.filter((seat) => seat !== action.seat);\n\t\t}\n\t});\n\treturn seats.length;\n};\n\nexport let getSeatActions = (\n\tstate: GameStateType,\n): Record<number, PlayerActionType[]> => {\n\tlet playerActions = playerActionsCurrentRound(state);\n\tlet seatActions: Record<number, PlayerActionType[]> = {};\n\tfor (let i = 0; i < state.players.length; i++) seatActions[i] = [];\n\tplayerActions.forEach((action) => {\n\t\tseatActions[action.seat].push(action);\n\t});\n\treturn seatActions;\n};\n\nexport let validateAction = (\n\tstate: GameStateType,\n\tnextAction: ActionType,\n): boolean | string => {\n\tlet options = next(state);\n\tif (options.length < 1)\n\t\treturn `There are less than one options (${options.length})`;\n\tif (isDealerAction(nextAction) && isDealerOptions(options)) {\n\t\tif (options.length > 1) return 'Dealer Options must only be length 1';\n\t\tif (options[0].action !== nextAction.action) {\n\t\t\treturn `Dealer action '${nextAction.action}' does not match option '${options[0].action}'`;\n\t\t}\n\t\treturn true;\n\t}\n\tif (isPlayerAction(nextAction) && isPlayerOptions(options)) {\n\t\tlet option = options.find((o) => o.action === nextAction.action);\n\t\tif (option === undefined)\n\t\t\treturn `nextAction ${\n\t\t\t\tnextAction.action\n\t\t\t} not in options ${optionArrayToString(options)}`;\n\n\t\tif (option.seat !== nextAction.seat)\n\t\t\treturn `Seat ${nextAction.seat} does not match option seat ${option.seat}`;\n\n\t\t// fold, check, blind, straddle are valid on their own\n\t\tif (\n\t\t\tnextAction.action === 'fold' ||\n\t\t\tnextAction.action === 'check' ||\n\t\t\tnextAction.action === 'straddle' ||\n\t\t\tnextAction.action === 'blind'\n\t\t)\n\t\t\treturn true;\n\n\t\t// call\n\t\tif (nextAction.action === 'call' && option.action === 'call') {\n\t\t\tif (nextAction.amount === option.amount) return true;\n\t\t\treturn `Call amount ${nextAction.amount} does not match option amount ${option.amount}`;\n\t\t}\n\n\t\t// bet\n\t\tif (nextAction.action === 'bet' && option.action === 'bet') {\n\t\t\tif (option.min === 'unknown' || option.max === 'unknown') return true;\n\t\t\tif (nextAction.amount >= option.min && nextAction.amount <= option.max)\n\t\t\t\treturn true;\n\t\t\treturn `Bet amount ${nextAction.amount} not in range ${option.min} - ${option.max}`;\n\t\t}\n\t}\n\n\treturn `Something went wrong => received action: ${\n\t\tnextAction.action\n\t} | options: ${optionArrayToString(options)}`;\n};\n\nexport let validateState = (state: GameStateType): boolean | string => {\n\tfor (let i = 0; i < state.actionList.length; i++) {\n\t\tlet prevState = structuredClone(state);\n\t\tprevState.actionList = state.actionList.slice(0, i);\n\t\tlet nextAction = state.actionList[i];\n\t\tlet valid = validateAction(prevState, nextAction);\n\t\tif (valid !== true) return `Invalid action at index ${i}: ${valid}`;\n\t}\n\treturn true;\n};\n","import {\n\tgetNextRoundOption,\n\ttype NextOptionType,\n\ttype PlayerActionType,\n} from './action.js';\nimport {\n\tactionComplete,\n\tgetCurrentRound,\n\tgetLargestWager,\n\tgetLargestWagerAmount,\n\tgetMinMaxBet,\n\tgetSeatOrder,\n\tgetStacksAtStartOfCurrentRound,\n\tgetWagers,\n\thasNonBlindAction,\n\thasNonBlindStraddleAction,\n\tplayerActionsCurrentRound,\n} from './engineUtils.js';\nimport { GameStateSchema, type GameStateType } from './state.js';\n\n// Attempt to work this through comments\nexport let next = (state: GameStateType): NextOptionType[] => {\n\tlet optionList: NextOptionType[] = [];\n\t// Check state first\n\tconst parse = GameStateSchema.safeParse(state);\n\tif (!parse.success) {\n\t\tthrow parse.error.errors[0].message;\n\t}\n\tstate = parse.data;\n\n\t// if the actionList is empty - return preflop only\n\tif (state.actionList.length === 0) {\n\t\treturn [{ action: 'preflop' }];\n\t}\n\n\t// we know we have a good schema, good actionList and atleast one item in it.\n\tlet lastAction = state.actionList[state.actionList.length - 1];\n\tif (lastAction.action === 'showdown') throw 'Game is over';\n\n\t// --- at this point we know we have atleast the start ---\n\n\t// get what round we are currently in\n\tlet currentRound = getCurrentRound(state);\n\n\t// if the action is complete, we need to move to the next round\n\tif (actionComplete(state)) return [getNextRoundOption(currentRound)];\n\n\t// get the player actions this round\n\tlet playerActions: PlayerActionType[] = playerActionsCurrentRound(state);\n\n\tlet seatOrder = getSeatOrder(state);\n\tlet wagers = getWagers(state);\n\tlet currSeat = seatOrder[0];\n\tlet stacksBehind = getStacksAtStartOfCurrentRound(state);\n\t//let remainingStacks = getRemainingStacks(state);\n\tlet largestRemainingStackBehind = Math.max(\n\t\t...stacksBehind.filter((stack) => stack !== 'unknown'),\n\t);\n\t// all unknown stacks will be increased to the largest stack\n\tlet adjustedRemainingStacksBehind: number[] = [];\n\n\tfor (let i = 0; i < stacksBehind.length; i++) {\n\t\tlet stack = stacksBehind[i];\n\t\tif (stack === 'unknown') {\n\t\t\tadjustedRemainingStacksBehind.push(largestRemainingStackBehind);\n\t\t} else {\n\t\t\tadjustedRemainingStacksBehind.push(stack);\n\t\t}\n\t}\n\tlet remainingStackBehind: number = adjustedRemainingStacksBehind[currSeat];\n\n\tlet [minBet, maxBet] = getMinMaxBet(state);\n\n\t// early edge cases\n\tif (state.actionList.length === 1) {\n\t\toptionList.push({ action: 'blind', seat: currSeat });\n\t\treturn optionList;\n\t}\n\n\t// Start compiling options\n\n\t// Dealer Options first\n\t// Is the round complete?\n\n\t// always have the option to fold\n\toptionList.push({ action: 'fold', seat: currSeat });\n\n\t// --CHECK--\n\t// if action hasnt been opened yet\n\tif (wagers.length === 0) {\n\t\toptionList.push({ action: 'check', seat: currSeat });\n\t} else {\n\t\t// if preflop, and the largest blind/straddle hasnt been raise, they can check\n\t\tif (currentRound === 'preflop') {\n\t\t\tlet lastWager = wagers[wagers.length - 1];\n\t\t\tif (lastWager.action === 'blind' || lastWager.action === 'straddle') {\n\t\t\t\tif (lastWager.seat === currSeat)\n\t\t\t\t\toptionList.push({ action: 'check', seat: currSeat });\n\t\t\t}\n\t\t}\n\t}\n\n\t// --CALL/BET--\n\tif (wagers.length === 0) {\n\t\toptionList.push({\n\t\t\taction: 'bet',\n\t\t\tseat: currSeat,\n\t\t\tmin: minBet,\n\t\t\tmax: maxBet,\n\t\t});\n\t}\n\tif (wagers.length > 0) {\n\t\tlet largestWagerAction = getLargestWager(state);\n\t\tlet largestWagerAmount = getLargestWagerAmount(state);\n\n\t\t// call option\n\t\t// Preflop edge case if you are the largest blind/straddle, you cant call your own blind/straddle\n\t\t// so we want to filter that out\n\t\tif (\n\t\t\tcurrentRound !== 'preflop' ||\n\t\t\t(largestWagerAction !== null && currSeat !== largestWagerAction.seat)\n\t\t) {\n\t\t\tif (largestWagerAmount >= remainingStackBehind) {\n\t\t\t\toptionList.push({\n\t\t\t\t\taction: 'call',\n\t\t\t\t\tseat: currSeat,\n\t\t\t\t\tamount: remainingStackBehind,\n\t\t\t\t\tisAllIn: true,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\toptionList.push({\n\t\t\t\t\taction: 'call',\n\t\t\t\t\tseat: currSeat,\n\t\t\t\t\tamount: largestWagerAmount,\n\t\t\t\t\tisAllIn: false,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\t// reopen option\n\t\t// if the seat hasnt acted they can always raise\n\t\t// unless the bet infront of them is larger than there stack\n\t\tif (largestWagerAmount < remainingStackBehind) {\n\t\t\tlet hasPlayerActed = playerActions.find((action) => {\n\t\t\t\treturn (\n\t\t\t\t\taction.seat === currSeat &&\n\t\t\t\t\taction.action !== 'blind' &&\n\t\t\t\t\taction.action !== 'straddle'\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (!hasPlayerActed) {\n\t\t\t\toptionList.push({\n\t\t\t\t\taction: 'bet',\n\t\t\t\t\tseat: currSeat,\n\t\t\t\t\tmin: minBet,\n\t\t\t\t\tmax: maxBet,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// if the seat has acted, they can only raise\n\t\t\t\t// if the action was reopened after their most recent action\n\t\t\t\tlet reopenPercent = state.options.reopenPercent;\n\t\t\t\tlet seatActionIdx = playerActions.findLastIndex(\n\t\t\t\t\t(action) => 'seat' in action && action.seat === currSeat,\n\t\t\t\t);\n\t\t\t\t// if the players last action was call/bet there will\n\t\t\t\t// be an amount, otherwise its check and 0\n\t\t\t\tlet smallBet =\n\t\t\t\t\t'amount' in playerActions[seatActionIdx]\n\t\t\t\t\t\t? playerActions[seatActionIdx].amount\n\t\t\t\t\t\t: 0;\n\t\t\t\tfor (let i = seatActionIdx + 1; i < playerActions.length; i++) {\n\t\t\t\t\tlet playerAction = playerActions[i];\n\t\t\t\t\tif (playerAction.action === 'bet') {\n\t\t\t\t\t\tlet largeBet = playerAction.amount;\n\t\t\t\t\t\tif (largeBet > smallBet + reopenPercent * smallBet) {\n\t\t\t\t\t\t\toptionList.push({\n\t\t\t\t\t\t\t\taction: 'bet',\n\t\t\t\t\t\t\t\tseat: currSeat,\n\t\t\t\t\t\t\t\tmin: minBet, // this might be wrong, but Jordan has me too tired to think through it\n\t\t\t\t\t\t\t\tmax: maxBet,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//blind/straddle edge case\n\tif (currentRound === 'preflop') {\n\t\tif (!hasNonBlindAction(state)) {\n\t\t\toptionList.push({ action: 'blind', seat: currSeat });\n\t\t\toptionList.push({ action: 'straddle', seat: currSeat });\n\t\t} else if (!hasNonBlindStraddleAction(state)) {\n\t\t\toptionList.push({ action: 'straddle', seat: currSeat });\n\t\t}\n\t}\n\n\treturn optionList;\n};\n"],"mappings":";AAAA,SAAS,KAAAA,UAAS;;;ACAlB,SAAS,SAAS;AAEX,IAAM,iBAAiB,EAAE,MAAM;AAAA,EACrC,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AACd,CAAC;AAEM,IAAM,iBAAiB,EAAE,MAAM;AAAA,EACrC,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AAAA,EACb,EAAE,QAAQ,GAAG;AACd,CAAC;AAIM,IAAM,aAAa,EAAE,OAAO;AAAA,EAClC,MAAM;AAAA,EACN,MAAM;AACP,CAAC;;;AD7BM,IAAM,mBAAmBC,GAAE,OAAO;AAAA,EACxC,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,MAAM;AACzB,CAAC;AAEM,IAAM,mBAAmBA,GAAE,OAAO;AAAA,EACxC,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,MAAM;AAAA,EACxB,QAAQA,GAAE,OAAO;AAAA,EACjB,SAASA,GAAE,QAAQ;AACpB,CAAC;AAEM,IAAM,kBAAkBA,GAAE,OAAO;AAAA,EACvC,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,KAAK;AAAA,EACvB,QAAQA,GAAE,OAAO;AAAA,EACjB,SAASA,GAAE,QAAQ;AACpB,CAAC;AAEM,IAAM,oBAAoBA,GAAE,OAAO;AAAA,EACzC,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,OAAO;AAC1B,CAAC;AAEM,IAAM,oBAAoBA,GAAE,OAAO;AAAA,EACzC,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,OAAO;AAAA,EACzB,QAAQA,GAAE,OAAO;AAAA,EACjB,SAASA,GAAE,QAAQ;AACpB,CAAC;AAEM,IAAM,uBAAuBA,GAAE,OAAO;AAAA,EAC5C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,UAAU;AAAA,EAC5B,QAAQA,GAAE,OAAO;AAAA,EACjB,SAASA,GAAE,QAAQ;AACpB,CAAC;AAQM,IAAM,sBAAsB,CAClC,WACuC;AACvC,SACC,OAAO,WAAW,SAClB,OAAO,WAAW,WAClB,OAAO,WAAW;AAEpB;AAGO,IAAM,sBAAsBA,GAAE,mBAAmB,UAAU;AAAA,EACjE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,CAAC;AAQM,IAAM,qBAAqBC,GAAE,mBAAmB,UAAU;AAAA,EAChEA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,SAAS;AAAA,EAC5B,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,MAAM;AAAA,IACxB,MAAMA,GAAE,MAAM,UAAU,EAAE,OAAO,CAAC;AAAA,EACnC,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,MAAM;AAAA,IACxB,MAAM;AAAA,EACP,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,OAAO;AAAA,IACzB,OAAO;AAAA,EACR,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,UAAU;AAAA,EAC7B,CAAC;AACF,CAAC;AAKM,IAAM,eAAeA,GAAE,mBAAmB,UAAU;AAAA,EAC1D,GAAG,oBAAoB;AAAA,EACvB,GAAG,mBAAmB;AACvB,CAAC;AAIM,IAAM,yBAAyBA,GAAE,OAAO;AAAA,EAC9C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,MAAM;AACzB,CAAC;AAGM,IAAI,0BAA0BA,GAAE,OAAO;AAAA,EAC7C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,OAAO;AAC1B,CAAC;AAGM,IAAI,6BAA6BA,GAAE,OAAO;AAAA,EAChD,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,UAAU;AAC7B,CAAC;AAKM,IAAM,yBAAyBA,GAAE,OAAO;AAAA,EAC9C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,MAAM;AAAA,EACxB,QAAQA,GAAE,OAAO;AAAA,EACjB,SAASA,GAAE,QAAQ;AACpB,CAAC;AAEM,IAAM,wBAAwBA,GAAE,OAAO;AAAA,EAC7C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,KAAK;AAAA,EACvB,KAAKA,GAAE,MAAM,CAACA,GAAE,OAAO,EAAE,IAAI,CAAC,GAAGA,GAAE,QAAQ,SAAS,CAAC,CAAC;AAAA,EACtD,KAAKA,GAAE,MAAM,CAACA,GAAE,OAAO,EAAE,IAAI,CAAC,GAAGA,GAAE,QAAQ,SAAS,CAAC,CAAC;AACvD,CAAC;AAEM,IAAM,0BAA0BA,GAAE,OAAO;AAAA,EAC/C,MAAMA,GAAE,OAAO;AAAA,EACf,QAAQA,GAAE,QAAQ,OAAO;AAC1B,CAAC;AAGM,IAAM,qBAAqBA,GAAE,mBAAmB,UAAU;AAAA,EAChE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACD,CAAC;AAIM,IAAM,qBAAqBA,GAAE,mBAAmB,UAAU;AAAA,EAChEA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,SAAS;AAAA,EAC5B,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,MAAM;AAAA,IACxB,OAAOA,GAAE,QAAQ,CAAC;AAAA,EACnB,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,MAAM;AAAA,IACxB,OAAOA,GAAE,QAAQ,CAAC;AAAA,EACnB,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,OAAO;AAAA,IACzB,OAAOA,GAAE,QAAQ,CAAC;AAAA,EACnB,CAAC;AAAA,EACDA,GAAE,OAAO;AAAA,IACR,QAAQA,GAAE,QAAQ,UAAU;AAAA,EAC7B,CAAC;AACF,CAAC;AAEM,IAAM,cAAc,CAAC,WAAW,QAAQ,QAAQ,OAAO;AAMvD,IAAM,mBAAmBA,GAAE,mBAAmB,UAAU;AAAA,EAC9D,GAAG,mBAAmB;AAAA,EACtB,GAAG,mBAAmB;AACvB,CAAC;AAIM,IAAM,iBAAiB,CAC7B,WACgC;AAChC,SAAO,oBAAoB,UAAU,MAAM,EAAE;AAC9C;AAEO,IAAM,iBAAiB,CAC7B,WACgC;AAChC,SAAO,mBAAmB,UAAU,MAAM,EAAE;AAC7C;AA0BO,IAAI,qBAAqB,CAAC,UAA4C;AAC5E,MAAI,UAAU,WAAW;AACxB,WAAO,EAAE,QAAQ,QAAQ,OAAO,EAAE;AAAA,EACnC,WAAW,UAAU,QAAQ;AAC5B,WAAO,EAAE,QAAQ,QAAQ,OAAO,EAAE;AAAA,EACnC,WAAW,UAAU,QAAQ;AAC5B,WAAO,EAAE,QAAQ,SAAS,OAAO,EAAE;AAAA,EACpC,OAAO;AACN,WAAO,EAAE,QAAQ,WAAW;AAAA,EAC7B;AACD;;;AE3OA,SAAS,KAAAC,UAAS;AAaX,IAAM,gBAAgBC,GAAE,OAAO;AAAA,EACrC,eAAeA,GAAE,OAAO,EAAE,QAAQ,CAAG;AACtC,CAAC;AAIM,IAAM,cAAcA,GAAE,MAAM;AAAA,EAClCA,GAAE,OAAO,EAAE,SAAS;AAAA,EACpBA,GAAE,QAAQ,SAAS;AACpB,CAAC;AAGM,IAAM,kBAAkBA,GAAE,OAAO;AAAA,EACvC,SAAS,cAAc,QAAQ,CAAC,CAAC;AAAA,EACjC,YAAY,aAAa,MAAM;AAAA,EAC/B,SAASA,GACP,OAAO;AAAA,IACP,eAAe;AAAA,IACf,OAAO,WAAW,MAAM,EAAE,OAAO,CAAC;AAAA,EACnC,CAAC,EACA,MAAM,EACN,IAAI,CAAC;AACR,CAAC;AAsNM,IAAI,UAAU,CAAC,UAA0C;AAC/D,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,OAAwB,CAAC;AAC7B,SAAO,QAAQ,CAAC,WAAW;AAC1B,QAAI,OAAO,WAAW,OAAO;AAC5B,WAAK,KAAK,MAAM;AAAA,IACjB;AAAA,EACD,CAAC;AACD,SAAO;AACR;AAEO,IAAI,qBAAqB,CAC/B,UAC8C;AAC9C,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,kBAA4D,CAAC;AACjE,SAAO,QAAQ,CAAC,WAAW;AAC1B,QAAI,OAAO,WAAW,WAAW,OAAO,WAAW,YAAY;AAC9D,sBAAgB,KAAK,MAAM;AAAA,IAC5B;AAAA,EACD,CAAC;AACD,SAAO;AACR;;;ACxPO,IAAI,4BAA4B,CACtC,UACwB;AACxB,MAAI,eAAe,gBAAgB,KAAK;AACxC,MAAI,WAAW,qBAAqB,OAAO,YAAY;AAEvD,MAAI,gBAAoC,CAAC;AACzC,WAAS,IAAI,UAAU,IAAI,MAAM,WAAW,QAAQ,KAAK;AACxD,QAAI,aAAa,MAAM,WAAW,CAAC;AACnC,QAAI,CAAC,eAAe,UAAU,GAAG;AAChC,oBAAc,KAAK,UAAU;AAAA,IAC9B;AAAA,EACD;AAEA,SAAO;AACR;AAEO,IAAI,kBAAkB,CAAC,UAAyC;AACtE,MAAI,gBAAgB,oBAAoB,KAAK;AAC7C,MAAI,cAAc,WAAW,EAAG,OAAM;AACtC,MAAI,cAAc,cAAc,SAAS,CAAC,EAAE,WAAW;AACtD,UAAM;AACP,SAAO,cAAc,cAAc,SAAS,CAAC,EAAE;AAChD;AAEO,IAAI,sBAAsB,CAAC,UAA6C;AAC9E,MAAI,gBAAoC,CAAC;AACzC,WAAS,IAAI,GAAG,IAAI,MAAM,WAAW,QAAQ,KAAK;AACjD,QAAI,aAAa,MAAM,WAAW,CAAC;AACnC,QAAI,eAAe,UAAU,GAAG;AAC/B,oBAAc,KAAK,UAAU;AAAA,IAC9B;AAAA,EACD;AACA,MAAI,cAAc,WAAW,EAAG,OAAM;AACtC,SAAO;AACR;AAEO,IAAI,uBAAuB,CACjC,OACA,UACY;AACZ,WAAS,IAAI,MAAM,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AACtD,QAAI,aAAa,MAAM,WAAW,CAAC;AACnC,QAAI,eAAe,UAAU,KAAK,WAAW,WAAW,OAAO;AAC9D,aAAO;AAAA,IACR;AAAA,EACD;AACA,SAAO;AACR;AAEO,IAAI,2BAA2B,CAAC,UAAmC;AACzE,MAAI,eAAe,gBAAgB,KAAK;AACxC,SAAO,qBAAqB,OAAO,YAAY;AAChD;AAEO,IAAI,uBAAuB,CACjC,OACA,UACc;AACd,MAAI,QAAkB,CAAC,GAAG,MAAM,MAAM,QAAQ,MAAM,EAAE,KAAK,CAAC;AAC5D,MAAI,gBAAgB,qBAAqB,OAAO,KAAK;AAErD,WAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACvC,QAAI,SAAS,MAAM,WAAW,CAAC;AAC/B,QACC,eAAe,MAAM,MACpB,OAAO,WAAW,UAAW,aAAa,UAAU,OAAO,UAC3D;AACD,cAAQ,MAAM,OAAO,CAAC,SAAS,SAAS,OAAO,IAAI;AAAA,IACpD;AAAA,EACD;AACA,SAAO;AACR;AAEO,IAAI,aAAa,CAAC,UAA8B;AACtD,MAAI,MAAM,SAAS,EAAG,QAAO,CAAC,GAAG,MAAM,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AACzD,SAAO;AACR;AAEO,IAAI,mBAAmB,CAAC,UAAiC;AAC/D,SAAO,MAAM,WAAW,OAAO,CAAC,KAAK,SAAS;AAC7C,QAAI,KAAK,WAAW,WAAW,KAAK,SAAS,IAAK,QAAO,KAAK;AAC9D,WAAO;AAAA,EACR,GAAG,CAAC;AACL;AAMO,IAAI,uBAAuB,CACjC,UACsC;AACtC,MAAI,aAAa,CAAC,GAAG,MAAM,MAAM,QAAQ,MAAM,EAAE,KAAK,CAAC,EAAE,IAAI,MAAM,CAAC;AACpE,MAAI,SAAS;AAAA,IACZ,SAAS,CAAC,GAAG,UAAU;AAAA,IACvB,MAAM,CAAC,GAAG,UAAU;AAAA,IACpB,MAAM,CAAC,GAAG,UAAU;AAAA,IACpB,OAAO,CAAC,GAAG,UAAU;AAAA,EACtB;AAEA,MAAI;AACJ,QAAM,WAAW,QAAQ,CAAC,QAAQ,QAAQ;AACzC,QAAI,eAAe,MAAM,GAAG;AAC3B,kBAAY,OAAO;AACnB;AAAA,IACD;AACA,QAAI,eAAe,MAAM,GAAG;AAC3B,UACC,YAAY,UACZ,OAAO,SAAS,EAAE,OAAO,IAAI,IAAI,OAAO,QACvC;AACD,eAAO,SAAS,EAAE,OAAO,IAAI,IAAI,OAAO;AAAA,MACzC;AAAA,IACD;AAAA,EACD,CAAC;AAED,SAAO;AACR;AAKO,IAAI,0BAA0B,CACpC,UACuB;AACvB,MAAI,iBAA8B,CAAC;AACnC,QAAM,QAAQ,QAAQ,CAAC,WAAW;AACjC,mBAAe,KAAK,OAAO,aAAa;AAAA,EACzC,CAAC;AAED,MAAI,SAAS;AAAA,IACZ,SAAS,gBAAgB,cAAc;AAAA,IACvC,MAAM,gBAAgB,cAAc;AAAA,IACpC,MAAM,gBAAgB,cAAc;AAAA,IACpC,OAAO,gBAAgB,cAAc;AAAA,EACtC;AAEA,MAAI,gBAAgB,qBAAqB,KAAK;AAI9C,WAAS,OAAO,GAAG,OAAO,MAAM,QAAQ,QAAQ,QAAQ;AACvD,QAAI,YAAY;AAChB,gBAAY,QAAQ,CAAC,UAA0B;AAC9C,UAAI,gBAAgB,OAAO,SAAS,EAAE,IAAI;AAC1C,UAAI,kBAAkB,UAAW;AACjC,UAAI,UAAU,WAAW;AACxB,oBAAY,cAAc,KAAK,EAAE,IAAI;AACrC;AAAA,MACD;AACA,aAAO,KAAK,EAAE,IAAI,IAAI,gBAAgB;AACtC,mBAAa,cAAc,KAAK,EAAE,IAAI;AAAA,IACvC,CAAC;AAAA,EACF;AACA,SAAO;AACR;AAEO,IAAI,iCAAiC,CAC3C,UACiB;AACjB,SAAO,wBAAwB,KAAK,EAAE,gBAAgB,KAAK,CAAC;AAC7D;AAsBO,IAAI,eAAe,CAAC,UAAmC;AAC7D,MAAI,gBAAoC,0BAA0B,KAAK;AACvE,MAAI,aAAa,yBAAyB,KAAK;AAC/C,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,QAAI,SAAS,cAAc,CAAC;AAC5B,QAAI,OAAO,WAAW,QAAQ;AAC7B,mBAAa,WAAW,OAAO,CAAC,SAAS,SAAS,OAAO,IAAI;AAC7D;AAAA,IACD;AACA,QAAI,aAAa,UAAU,OAAO,SAAS;AAC1C,mBAAa,WAAW,OAAO,CAAC,SAAS,SAAS,OAAO,IAAI;AAC7D;AAAA,IACD;AACA,iBAAa,WAAW,UAAU;AAAA,EACnC;AACA,SAAO;AACR;AAGO,IAAI,YAAY,CAAC,UAAoD;AAC3E,MAAI,gBAAoC,0BAA0B,KAAK;AACvE,MAAI,SAAoC,CAAC;AACzC,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,QAAI,SAAS,cAAc,CAAC;AAC5B,QAAI,oBAAoB,MAAM,EAAG,QAAO,KAAK,MAAM;AAAA,EACpD;AACA,SAAO;AACR;AAGO,IAAI,mBAAmB,CAAC,UAAmC;AACjE,MAAI,gBAAgB,CAAC,GAAG,MAAM,MAAM,QAAQ,MAAM,EAAE,KAAK,CAAC,EAAE,IAAI,MAAM,CAAC;AACvE,MAAI,SAAoC,UAAU,KAAK;AACvD,SAAO,QAAQ,CAAC,UAAU;AACzB,QAAI,MAAM,SAAS,cAAc,MAAM,IAAI,GAAG;AAC7C,oBAAc,MAAM,IAAI,IAAI,MAAM;AAAA,IACnC;AAAA,EACD,CAAC;AACD,SAAO;AACR;AAEO,IAAI,kBAAkB,CAC5B,UACoC;AACpC,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,OAAO,WAAW,EAAG,QAAO;AAChC,SAAO,OAAO,OAAO,CAAC,KAAK,SAAS;AACnC,QAAI,KAAK,SAAS,IAAI,OAAQ,QAAO;AACrC,WAAO;AAAA,EACR,CAAC;AACF;AAEO,IAAI,wBAAwB,CAAC,UAAiC;AACpE,SAAO,gBAAgB,KAAK,GAAG,UAAU;AAC1C;AAEO,IAAI,qBAAqB,CAAC,UAAsC;AACtE,MAAI,YAAY,gBAAgB,KAAK;AACrC,MAAI,gBAAgB,wBAAwB,KAAK,EAAE,SAAS;AAC5D,MAAI,eAAe,iBAAiB,KAAK;AAEzC,MAAI,aAAa,MAAM,QAAQ;AAC/B,MAAI,kBAAkB,CAAC,GAAG,aAAa;AACvC,WAAS,OAAO,GAAG,OAAO,YAAY,QAAQ;AAC7C,QAAI,iBAAiB,cAAc,IAAI;AACvC,QAAI,mBAAmB;AACtB,sBAAgB,IAAI,IAAI,iBAAiB,aAAa,IAAI;AAAA,EAC5D;AACA,SAAO;AACR;AAIO,IAAI,YAAY,CAAC,UAAiC;AACxD,MAAI,SAAS;AACb,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,WAAW,aAAa,KAAK,EAAE,GAAG,CAAC;AACvC,MAAI,aAAa,OAAW,OAAM;AAClC,MAAI,eAAe,iBAAiB,KAAK;AACzC,WAAS;AACT,MAAI,eAA0C,CAAC;AAC/C,MAAI,OAAO,SAAS,GAAG;AAEtB,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,UAAI,OAAO,CAAC,EAAE,SAAS;AAEtB,YAAI,aAAa,SAAS,GAAG;AAC5B,cAAI,WAAW,aAAa,aAAa,SAAS,CAAC,EAAE;AACrD,cAAI,WAAW,aAAa,aAAa,SAAS,CAAC,EAAE;AACrD,cAAI,YAAY,WAAW;AAC3B,cAAI,OAAO,CAAC,EAAE,UAAU,WAAW,WAAW;AAC7C,yBAAa,KAAK,OAAO,CAAC,CAAC;AAAA,UAC5B;AAAA,QACD;AAEA,YAAI,aAAa,WAAW,GAAG;AAC9B,uBAAa,KAAK,OAAO,CAAC,CAAC;AAAA,QAC5B;AAAA,MACD,OAAO;AACN,qBAAa,KAAK,OAAO,CAAC,CAAC;AAAA,MAC5B;AAAA,IACD;AAAA,EACD;AACA,MAAI,OAAO,WAAW,GAAG;AACxB,iBAAa,KAAK,OAAO,CAAC,CAAC;AAAA,EAC5B;AAEA,MAAI,aAAa,WAAW,GAAG;AAC9B,aAAS;AAAA,EACV;AACA,MAAI,aAAa,WAAW,GAAG;AAC9B,aAAS,aAAa,CAAC,EAAE,SAAS;AAAA,EACnC;AACA,MAAI,aAAa,SAAS,GAAG;AAC5B,QAAI,WAAW,aAAa,aAAa,SAAS,CAAC,EAAE;AACrD,QAAI,WAAW,aAAa,aAAa,SAAS,CAAC,EAAE;AACrD,QAAI,YAAY,WAAW;AAC3B,aAAS,WAAW;AAAA,EACrB;AACA,SAAO;AACR;AAEO,IAAI,kBAAkB,CAAC,UAAiC;AAC9D,MAAI,SAAS,+BAA+B,KAAK;AACjD,MAAI,eAAe;AACnB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,QAAI,YAAY,OAAO,CAAC;AACxB,QAAI,cAAc,aAAa,YAAY,cAAc;AACxD,qBAAe;AAAA,IAChB;AAAA,EACD;AACA,SAAO;AACR;AAEO,IAAI,YAAY,CAAC,UAAiC;AACxD,MAAI,WAAW,aAAa,KAAK,EAAE,GAAG,CAAC;AACvC,MAAI,aAAa,OAAW,OAAM;AAElC,MAAI,SAAS,mBAAmB,KAAK,EAAE,GAAG,QAAQ;AAClD,MAAI,WAAW,OAAW,OAAM;AAEhC,MAAI,WAAW,UAAW,QAAO,gBAAgB,KAAK;AAEtD,SAAO;AACR;AAKO,IAAI,eAAe,CAAC,UAA2C;AACrE,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,SAAS,UAAU,KAAK;AAE5B,MAAI,SAAS,OAAQ,QAAO,CAAC,QAAQ,MAAM;AAC3C,SAAO,CAAC,QAAQ,MAAM;AACvB;AAEO,IAAI,oBAAoB,CAAC,UAAkC;AACjE,SACC,MAAM,WAAW;AAAA,IAChB,CAAC,MAAM,EAAE,WAAW,WAAW,EAAE,WAAW;AAAA,EAC7C,EAAE,SAAS;AAEb;AAEO,IAAI,4BAA4B,CAAC,UAAkC;AACzE,SACC,MAAM,WAAW;AAAA,IAChB,CAAC,MACA,EAAE,WAAW,WACb,EAAE,WAAW,cACb,EAAE,WAAW;AAAA,EACf,EAAE,SAAS;AAEb;AAIO,IAAI,iBAAiB,CAAC,UAAkC;AAC9D,MAAI,MAAM,WAAW,UAAU,EAAG,QAAO;AAEzC,MAAI,gBAAgB,0BAA0B,KAAK;AACnD,MAAI,QAAQ,yBAAyB,KAAK;AAC1C,MAAI,eAAe,sBAAsB,KAAK;AAI9C,MAAI,cAAc,WAAW,KAAK,MAAM,UAAU,GAAG;AACpD,WAAO;AAAA,EACR;AAIA,MACC,cAAc,WAAW,MAAM,UAC/B,iBAAiB,KACjB,gBAAgB,KAAK,MAAM,WAC1B;AACD,WAAO;AAAA,EACR;AAGA,MAAI,gBAAgB,KAAK,MAAM,aAAa,QAAQ,KAAK,EAAE,WAAW,GAAG;AACxE,WACC,cAAc,WAAW,MAAM,SAAS,mBAAmB,KAAK,EAAE;AAAA,EAEpE;AAIA,MAAI,aAAa,gBAAgB,KAAK;AACtC,MAAI,mBAAyC;AAC7C,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9C,QAAI,aAAa,cAAc,CAAC;AAChC,QAAI,WAAW,WAAW,QAAQ;AACjC,mBAAa,WAAW,OAAO,CAAC,SAAS,SAAS,WAAW,IAAI;AACjE;AAAA,IACD;AACA,QAAI,WAAW,WAAW,OAAO;AAChC,UACC,qBAAqB,QACrB,WAAW,SAAS,iBAAiB,QACpC;AACD,2BAAmB;AAAA,MACpB;AAAA,IACD;AACA,iBAAa,WAAW,UAAU;AAAA,EACnC;AAEA,SAAO,WAAW,CAAC,MAAM,kBAAkB;AAC5C;;;AChaO,IAAI,OAAO,CAAC,UAA2C;AAC7D,MAAI,aAA+B,CAAC;AAEpC,QAAM,QAAQ,gBAAgB,UAAU,KAAK;AAC7C,MAAI,CAAC,MAAM,SAAS;AACnB,UAAM,MAAM,MAAM,OAAO,CAAC,EAAE;AAAA,EAC7B;AACA,UAAQ,MAAM;AAGd,MAAI,MAAM,WAAW,WAAW,GAAG;AAClC,WAAO,CAAC,EAAE,QAAQ,UAAU,CAAC;AAAA,EAC9B;AAGA,MAAI,aAAa,MAAM,WAAW,MAAM,WAAW,SAAS,CAAC;AAC7D,MAAI,WAAW,WAAW,WAAY,OAAM;AAK5C,MAAI,eAAe,gBAAgB,KAAK;AAGxC,MAAI,eAAe,KAAK,EAAG,QAAO,CAAC,mBAAmB,YAAY,CAAC;AAGnE,MAAI,gBAAoC,0BAA0B,KAAK;AAEvE,MAAI,YAAY,aAAa,KAAK;AAClC,MAAI,SAAS,UAAU,KAAK;AAC5B,MAAI,WAAW,UAAU,CAAC;AAC1B,MAAI,eAAe,+BAA+B,KAAK;AAEvD,MAAI,8BAA8B,KAAK;AAAA,IACtC,GAAG,aAAa,OAAO,CAAC,UAAU,UAAU,SAAS;AAAA,EACtD;AAEA,MAAI,gCAA0C,CAAC;AAE/C,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC7C,QAAI,QAAQ,aAAa,CAAC;AAC1B,QAAI,UAAU,WAAW;AACxB,oCAA8B,KAAK,2BAA2B;AAAA,IAC/D,OAAO;AACN,oCAA8B,KAAK,KAAK;AAAA,IACzC;AAAA,EACD;AACA,MAAI,uBAA+B,8BAA8B,QAAQ;AAEzE,MAAI,CAAC,QAAQ,MAAM,IAAI,aAAa,KAAK;AAGzC,MAAI,MAAM,WAAW,WAAW,GAAG;AAClC,eAAW,KAAK,EAAE,QAAQ,SAAS,MAAM,SAAS,CAAC;AACnD,WAAO;AAAA,EACR;AAQA,aAAW,KAAK,EAAE,QAAQ,QAAQ,MAAM,SAAS,CAAC;AAIlD,MAAI,OAAO,WAAW,GAAG;AACxB,eAAW,KAAK,EAAE,QAAQ,SAAS,MAAM,SAAS,CAAC;AAAA,EACpD,OAAO;AAEN,QAAI,iBAAiB,WAAW;AAC/B,UAAI,YAAY,OAAO,OAAO,SAAS,CAAC;AACxC,UAAI,UAAU,WAAW,WAAW,UAAU,WAAW,YAAY;AACpE,YAAI,UAAU,SAAS;AACtB,qBAAW,KAAK,EAAE,QAAQ,SAAS,MAAM,SAAS,CAAC;AAAA,MACrD;AAAA,IACD;AAAA,EACD;AAGA,MAAI,OAAO,WAAW,GAAG;AACxB,eAAW,KAAK;AAAA,MACf,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,KAAK;AAAA,MACL,KAAK;AAAA,IACN,CAAC;AAAA,EACF;AACA,MAAI,OAAO,SAAS,GAAG;AACtB,QAAI,qBAAqB,gBAAgB,KAAK;AAC9C,QAAI,qBAAqB,sBAAsB,KAAK;AAKpD,QACC,iBAAiB,aAChB,uBAAuB,QAAQ,aAAa,mBAAmB,MAC/D;AACD,UAAI,sBAAsB,sBAAsB;AAC/C,mBAAW,KAAK;AAAA,UACf,QAAQ;AAAA,UACR,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,SAAS;AAAA,QACV,CAAC;AAAA,MACF,OAAO;AACN,mBAAW,KAAK;AAAA,UACf,QAAQ;AAAA,UACR,MAAM;AAAA,UACN,QAAQ;AAAA,UACR,SAAS;AAAA,QACV,CAAC;AAAA,MACF;AAAA,IACD;AAKA,QAAI,qBAAqB,sBAAsB;AAC9C,UAAI,iBAAiB,cAAc,KAAK,CAAC,WAAW;AACnD,eACC,OAAO,SAAS,YAChB,OAAO,WAAW,WAClB,OAAO,WAAW;AAAA,MAEpB,CAAC;AACD,UAAI,CAAC,gBAAgB;AACpB,mBAAW,KAAK;AAAA,UACf,QAAQ;AAAA,UACR,MAAM;AAAA,UACN,KAAK;AAAA,UACL,KAAK;AAAA,QACN,CAAC;AAAA,MACF,OAAO;AAGN,YAAI,gBAAgB,MAAM,QAAQ;AAClC,YAAI,gBAAgB,cAAc;AAAA,UACjC,CAAC,WAAW,UAAU,UAAU,OAAO,SAAS;AAAA,QACjD;AAGA,YAAI,WACH,YAAY,cAAc,aAAa,IACpC,cAAc,aAAa,EAAE,SAC7B;AACJ,iBAAS,IAAI,gBAAgB,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC9D,cAAI,eAAe,cAAc,CAAC;AAClC,cAAI,aAAa,WAAW,OAAO;AAClC,gBAAI,WAAW,aAAa;AAC5B,gBAAI,WAAW,WAAW,gBAAgB,UAAU;AACnD,yBAAW,KAAK;AAAA,gBACf,QAAQ;AAAA,gBACR,MAAM;AAAA,gBACN,KAAK;AAAA;AAAA,gBACL,KAAK;AAAA,cACN,CAAC;AAAA,YACF;AAAA,UACD;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAGA,MAAI,iBAAiB,WAAW;AAC/B,QAAI,CAAC,kBAAkB,KAAK,GAAG;AAC9B,iBAAW,KAAK,EAAE,QAAQ,SAAS,MAAM,SAAS,CAAC;AACnD,iBAAW,KAAK,EAAE,QAAQ,YAAY,MAAM,SAAS,CAAC;AAAA,IACvD,WAAW,CAAC,0BAA0B,KAAK,GAAG;AAC7C,iBAAW,KAAK,EAAE,QAAQ,YAAY,MAAM,SAAS,CAAC;AAAA,IACvD;AAAA,EACD;AAEA,SAAO;AACR;","names":["z","z","z","z","z"]}